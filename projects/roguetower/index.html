<!DOCTYPE html><html lang="ko" class="scroll-smooth"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="preload" href="/towerdefense-portfolio/_next/static/media/e4af272ccee01ff0-s.p.woff2" as="font" crossorigin="" type="font/woff2"/><link rel="preload" as="image" href="/towerdefense-portfolio/SiteLogo.png"/><link rel="preload" as="image" href="/towerdefense-portfolio/icon/unity.png"/><link rel="preload" as="image" href="/towerdefense-portfolio/icon/csharp.png"/><link rel="preload" as="image" href="/towerdefense-portfolio/icon/ase.png"/><link rel="preload" as="image" href="/towerdefense-portfolio/icon/PlayFab.jpg"/><link rel="preload" as="image" href="/towerdefense-portfolio/Desc/Lobby.png"/><link rel="preload" as="image" href="/towerdefense-portfolio/Desc/IngameUI.png"/><link rel="preload" as="image" href="/towerdefense-portfolio/Desc/TowerButton.png"/><link rel="preload" as="image" href="/towerdefense-portfolio/Desc/SkillButton.png"/><link rel="preload" as="image" href="/towerdefense-portfolio/Desc/Perk.png"/><link rel="stylesheet" href="/towerdefense-portfolio/_next/static/css/9aecf071dd42db73.css" data-precedence="next"/><link rel="stylesheet" href="/towerdefense-portfolio/_next/static/css/986f079464c860c4.css" data-precedence="next"/><link rel="preload" href="/towerdefense-portfolio/_next/static/chunks/webpack-5320886ccfd4601e.js" as="script" fetchPriority="low"/><script src="/towerdefense-portfolio/_next/static/chunks/fd9d1056-d8f6cc25471773ac.js" async=""></script><script src="/towerdefense-portfolio/_next/static/chunks/864-cda1ba0f2cbf2968.js" async=""></script><script src="/towerdefense-portfolio/_next/static/chunks/main-app-ad7cc76e14caadbb.js" async=""></script><link rel="preload" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" as="script"/><link rel="preload" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-csharp.min.js" as="script"/><link rel="preload" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js" as="script"/><link rel="preload" as="image" href="/towerdefense-portfolio/Desc/RandomReward.png"/><link rel="preload" as="image" href="/towerdefense-portfolio/Desc/WaitingRoom.png"/><link rel="preload" as="image" href="/towerdefense-portfolio/Desc/Collect.png"/><link rel="preload" as="image" href="/towerdefense-portfolio/Desc/Store1.png"/><link rel="preload" as="image" href="/towerdefense-portfolio/Desc/Store3.png"/><link rel="preload" as="image" href="/towerdefense-portfolio/Desc/StoreAnimation.gif"/><link rel="preload" as="image" href="/towerdefense-portfolio/Desc/Store4.png"/><link rel="preload" as="image" href="/towerdefense-portfolio/Desc/InfinityMode.png"/><link rel="preload" as="image" href="/towerdefense-portfolio/Desc/DamageMeter.png"/><link rel="preload" as="image" href="/towerdefense-portfolio/Desc/IngameReaderBoard.png"/><link rel="preload" as="image" href="/towerdefense-portfolio/Desc/PlayFabReaderBoard.png"/><link rel="preload" as="image" href="/towerdefense-portfolio/Desc/Pooling1.png"/><link rel="preload" as="image" href="/towerdefense-portfolio/Desc/Pooling2.png"/><link rel="preload" as="image" href="/towerdefense-portfolio/Desc/RandomMap1.png"/><link rel="preload" as="image" href="/towerdefense-portfolio/Desc/RandomMap2.png"/><link rel="preload" as="image" href="/towerdefense-portfolio/Desc/RandomMap3.png"/><link rel="preload" as="image" href="/towerdefense-portfolio/Desc/Tooltip1.png"/><link rel="preload" as="image" href="/towerdefense-portfolio/Desc/Tooltip3.png"/><link rel="preload" as="image" href="/towerdefense-portfolio/Desc/Tooltip2.png"/><link rel="preload" as="image" href="/towerdefense-portfolio/Desc/Tooltip4.png"/><link rel="preload" as="image" href="/towerdefense-portfolio/Desc/PlayFabCombatData.png"/><link rel="preload" as="image" href="/towerdefense-portfolio/Desc/PlayFabError.png"/><link rel="preload" as="image" href="/towerdefense-portfolio/character/CharacterBase01.png"/><link rel="preload" as="image" href="/towerdefense-portfolio/character/WarriorTower01.png"/><link rel="preload" as="image" href="/towerdefense-portfolio/character/SpearTower01.png"/><link rel="preload" as="image" href="/towerdefense-portfolio/character/ArcherTower01.png"/><link rel="preload" as="image" href="/towerdefense-portfolio/character/LaserTower01.png"/><link rel="preload" as="image" href="/towerdefense-portfolio/character/BuffTower01.png"/><link rel="preload" as="image" href="/towerdefense-portfolio/character/WarriorTower02.png"/><link rel="preload" as="image" href="/towerdefense-portfolio/character/WarriorTower03.png"/><link rel="preload" as="image" href="/towerdefense-portfolio/character/CharacterBaseAnim.png"/><link rel="preload" as="image" href="/towerdefense-portfolio/character/WarriorTowerAnim.png"/><link rel="preload" as="image" href="/towerdefense-portfolio/character/SpearTowerAnim.png"/><link rel="preload" as="image" href="/towerdefense-portfolio/character/ArcherTowerAnim.png"/><link rel="preload" as="image" href="/towerdefense-portfolio/character/BuffTowerAnim.png"/><link rel="preload" as="image" href="/towerdefense-portfolio/character/LaserTowerAnim.png"/><link rel="preload" as="image" href="/towerdefense-portfolio/character/AvatarOfVengeance.png"/><link rel="preload" as="image" href="/towerdefense-portfolio/character/CommanderFlag.png"/><link rel="preload" as="image" href="/towerdefense-portfolio/UI/SkillFist.png"/><link rel="preload" as="image" href="/towerdefense-portfolio/UI/SkillSlow.png"/><link rel="preload" as="image" href="/towerdefense-portfolio/UI/ArrowRain.png"/><link rel="preload" as="image" href="/towerdefense-portfolio/UI/SkillThunder.png"/><link rel="preload" as="image" href="/towerdefense-portfolio/UI/SkillDamageUp.png"/><link rel="preload" as="image" href="/towerdefense-portfolio/UI/SkillSpearLanding.png"/><link rel="preload" as="image" href="/towerdefense-portfolio/UI/Tileset.png"/><link rel="preload" as="image" href="/towerdefense-portfolio/UI/Tileset_Snow.png"/><link rel="preload" as="image" href="/towerdefense-portfolio/UI/Tileset_Desert.png"/><link rel="preload" as="image" href="/towerdefense-portfolio/UI/Tileset_Magma.png"/><link rel="preload" as="image" href="/towerdefense-portfolio/UI/Arrow.png"/><link rel="preload" as="image" href="/towerdefense-portfolio/UI/Stone.png"/><link rel="preload" as="image" href="/towerdefense-portfolio/Equipment/accessory_avatar_of_vengeance.png"/><link rel="preload" as="image" href="/towerdefense-portfolio/Equipment/accessory_drum_of_battle.png"/><link rel="preload" as="image" href="/towerdefense-portfolio/Equipment/accessory_heart_of_life_reversal.png"/><link rel="preload" as="image" href="/towerdefense-portfolio/Equipment/accessory_vitality_doll.png"/><link rel="preload" as="image" href="/towerdefense-portfolio/Equipment/armor_berserker_cuirass.png"/><link rel="preload" as="image" href="/towerdefense-portfolio/Equipment/armor_immortal_cuirass.png"/><link rel="preload" as="image" href="/towerdefense-portfolio/Equipment/armor_shadow_lord_armor.png"/><link rel="preload" as="image" href="/towerdefense-portfolio/Equipment/armor_starlight_robe.png"/><link rel="preload" as="image" href="/towerdefense-portfolio/Equipment/boot_atlas_steps.png"/><link rel="preload" as="image" href="/towerdefense-portfolio/Equipment/boot_dragon_roar.png"/><link rel="preload" as="image" href="/towerdefense-portfolio/Equipment/boot_ghost_boots.png"/><link rel="preload" as="image" href="/towerdefense-portfolio/Equipment/boot_stormwing_boots.png"/><link rel="preload" as="image" href="/towerdefense-portfolio/Equipment/glove_meteor_gloves.png"/><link rel="preload" as="image" href="/towerdefense-portfolio/Equipment/glove_shadow_woven_gloves.png"/><link rel="preload" as="image" href="/towerdefense-portfolio/Equipment/glove_time_warp_gloves.png"/><link rel="preload" as="image" href="/towerdefense-portfolio/Equipment/glove_titan_gauntlets.png"/><link rel="preload" as="image" href="/towerdefense-portfolio/Equipment/helmet_ancient_dragon_skull.png"/><link rel="preload" as="image" href="/towerdefense-portfolio/Equipment/helmet_crown_of_dominion.png"/><link rel="preload" as="image" href="/towerdefense-portfolio/Equipment/helmet_shadow_tracker_helmet.png"/><link rel="preload" as="image" href="/towerdefense-portfolio/Equipment/helmet_silver_helmet.png"/><link rel="preload" as="image" href="/towerdefense-portfolio/Equipment/weapon_bloodlust.png"/><link rel="preload" as="image" href="/towerdefense-portfolio/Equipment/weapon_divine_punishment_bow.png"/><link rel="preload" as="image" href="/towerdefense-portfolio/Equipment/weapon_rune_blade.png"/><link rel="preload" as="image" href="/towerdefense-portfolio/Equipment/weapon_world_tree_staff.png"/><title>WooGeun Nam</title><meta name="description" content="웹 포트폴리오"/><link rel="icon" href="./../Logo.ico"/><meta name="next-size-adjust"/><title>RogueTower 게임기획서</title><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css"/><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.css"/><script src="/towerdefense-portfolio/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js" noModule=""></script></head><body class="__className_94e1b1 min-h-dvh bg-gray-100 antialiased"><section><header class="fixed top-0 inset-x-0 z-50 bg-white/80 backdrop-blur border-b"><nav class="mx-auto max-w-6xl px-4 h-14 flex items-center justify-between"><a class="font-semibold" href="/towerdefense-portfolio/portfolio/">WooGeun Nam</a><div class="flex gap-5 text-sm"><a class="px-1 transition-colors text-gray-600 hover:text-gray-900" href="/towerdefense-portfolio/portfolio/">Home</a><a class="px-1 transition-colors text-gray-600 hover:text-gray-900" href="/towerdefense-portfolio/portfolio/#projects">Projects</a><a class="px-1 transition-colors text-gray-600 hover:text-gray-900" href="/towerdefense-portfolio/portfolio/#resume">Resume</a></div></nav></header><main class="mx-auto w-full max-w-6xl pt-16"><main class="mx-auto max-w-6xl px-4 py-16 space-y-12"><section class="grid gap-8 md:grid-cols-2 items-stretch"><div class="rounded-xl overflow-hidden shadow-sm"><img src="/towerdefense-portfolio/SiteLogo.png" alt="RogueTower 메인" class="w-full h-full object-cover"/></div><div class="flex flex-col justify-between"><div><h1 class="text-4xl font-bold underline decoration-blue-500 underline-offset-8">RogueTower</h1><dl class="grid grid-cols-[120px_1fr] gap-x-4 gap-y-6 text-gray-800 mt-8"><dt class="font-semibold text-gray-600">ROLE</dt><dd>Programmer, Game Designer, Artist</dd><dt class="font-semibold text-gray-600">DURATION</dt><dd>2024.10 ~ 2025.08</dd><dt class="font-semibold text-gray-600">TEAM</dt><dd>1인 개발</dd><dt class="font-semibold text-gray-600">PLATFORM</dt><dd>PC</dd></dl></div><div class="mt-6 flex gap-4"><a href="https://github.com/WooGeun-Nam/RogueTower-Code" target="_blank" rel="noopener noreferrer" class="inline-flex items-center gap-2 rounded-full px-5 py-3 text-sm font-semibold bg-gray-200 text-gray-900 hover:bg-gray-300 focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-blue-300">GitHub Source</a></div></div></section><section class="pt-8"><div class="w-full py-8"><div class="w-full"><div class="flex w-full"><button class="flex-1 py-2 font-semibold transition border border-b-0
              bg-white text-blue-600 border-gray-300
              rounded-tl-lg
              ">기획서</button><button class="flex-1 py-2 font-semibold transition border border-b-0
              bg-gray-100 text-gray-600 border-gray-200 hover:bg-gray-200
              
              ">배포</button><button class="flex-1 py-2 font-semibold transition border border-b-0
              bg-gray-100 text-gray-600 border-gray-200 hover:bg-gray-200
              
              rounded-tr-lg">개발일지</button></div><div class="w-full bg-white border border-t-0 border-gray-300 rounded-b-lg shadow p-6"><div style="display:none"><div class="space-y-6"><h2 class="text-2xl font-bold mb-4">데모 &amp; 테스트 빌드</h2><p class="text-xs text-gray-600 mb-4">※ 폴더 내 2DTowerDefense.exe 또는 RogueTower.exe 파일을 통해 게임 실행</p><div class="mb-6 p-4 border rounded-lg bg-white shadow-sm"><h3 class="text-lg font-bold mb-3">프로젝트 정보 (Project Info)</h3><div class="space-y-2 text-sm"><p><span class="font-semibold w-28 inline-block">명칭 :</span><span>RogueTower</span></p><p><span class="font-semibold w-28 inline-block">개발 환경:</span><span>Unity, C#, PlayFab, Aseprite</span></p><p><span class="font-semibold w-28 inline-block">소스 코드:</span><span>https://github.com/WooGeun-Nam/RogueTower-Code</span></p><p><span class="font-semibold w-28 inline-block">상세 정보:</span><a href="#" class="text-blue-600 hover:underline">게임 기획서 보기</a><span class="mx-2">|</span><a href="#" class="text-blue-600 hover:underline">개발 일지 보기</a></p></div></div><div class="mb-4"><label for="versionSelect" class="font-semibold mr-2">빌드 버전 선택:</label><select id="versionSelect" class="px-3 py-1 border rounded"><option value="v0.2.4-beta" selected="">Beta Test Build (v0.2.4)</option><option value="v0.1.0-beta">Beta Test Build (v0.1.0)</option><option value="v0.3.0-alpha">Alpha Test Build (v0.3.0)</option><option value="v0.2.0">Alpha Test Build (v0.2.0)</option><option value="v0.1.0">Alpha Test Build (v0.1.0)</option></select></div><div class="p-4 bg-gray-100 rounded mb-6"><div class="grid grid-cols-2 items-center mb-4"><p class="font-semibold text-lg">Beta Test Build (v0.2.4)</p><div class="flex justify-end"><a href="https://drive.google.com/file/d/1f3eNnKfts_eKnNyIHo1nAcWxsLohogxM/view?usp=sharing" target="_blank" rel="noopener noreferrer" class="px-4 py-2 bg-green-500 text-white rounded hover:bg-green-600 text-sm">다운로드</a></div></div><p class="text-xs text-gray-600 mb-4">※ 이전 버전의 저장 데이터와 호환 합니다.</p><h4 class="font-semibold mb-2">무한모드</h4><ul class="list-disc pl-5 text-sm mb-4 space-y-1"><li>기존모드의 100 난이도 클리어 시 개방</li><li>최종 웨이브가 존재하지 않는다.</li><li>웨이브당 제한시간이 존재한다 (2분)</li><li>적이 죽지 않고 최종위치에 도착하면, 시작위치로 순환한다.</li><li>제한시간 안에 남은 적이 0이 되면 웨이브 클리어</li><li>제한시간 안에 남은 적이 있다면 적 한개당 HP가 1 감소한다.</li><li>체력이 0이하가 되어 게임이 종료되면 최종점수를 정산한다.</li><li>무한모드는 상위표가 존재하며 최종점수를 기준으로 등록가능</li><li>상위 10명의 점수표를 타이틀 화면에서 확인할 수 있다.</li><li>우측상단의 버튼을 이용해 데미지 분석 사용 가능</li></ul><h4 class="font-semibold mb-2">추가</h4><ul class="list-disc pl-5 text-sm mb-4 space-y-1"><li>사막 맵 추가</li><li>용암 맵 추가</li><li>인게임 실시간 점수 표기 추가</li><li>게임속도 전환 단축키 추가 : Q</li><li>인게임 단축키 설명 패널 추가</li><li>중복장비 보상 RCoin 지급 기능 추가</li><li>타이틀화면 상점/순위표 추가</li><li>상점 : RCoin 을 이용하여 장비뽑기를 할 수 있습니다. (고정확률)</li><li>순위표 : 무한모드 의 글로벌 순위표를 확인할 수 있습니다.</li></ul><h4 class="font-semibold mb-2">밸런스</h4><ul class="list-disc pl-5 text-sm mb-4 space-y-1"><li><b>타워 밸런스 조정 : </b>궁수 타워 하향, 창 타워 상향</li><li>무기 장비 옵션 재설정</li><li>장비 공격 사거리 옵션 하향</li><li>웨이브 랜덤 보상 : 물리/마법 업그레이드 상향 (10웨이브 마다 수치증가)</li><li>타워형 스킬 상향 : 복수의 화신, 기본타워스킬</li></ul><h4 class="font-semibold mb-2">수정 및 개선</h4><ul class="list-disc pl-5 text-sm mb-4 space-y-1"><li><b>툴팁 관련 개선 : </b>일부 장신구 툴팁 개선(관련 효과 실시간 표기), 궁수 타워 툴팁 개선</li><li><b>소리 관련 개선 : </b>일부 소리 누락문제 개선, 기능별 신규 사운드 추가</li><li>UI 전환속도 개선</li><li>타워/스킬 전환 버그 수정</li><li>전설급 장비 이미지 수정</li><li>해상도에 따른 UI문제 개선</li><li>랜덤 보상 표기문제 수정</li><li>낙뢰스킬 잔상 버그 수정</li><li>인게임 UI 가시성 개선</li><li>약자 멸시 / 연쇄 폭발 특성 기능 누락 개선</li><li>튜토리얼 개선 및 신규 내용 추가</li><li>업그레이드 비용 가시성 개선</li><li>버전 표기 및 License 표기</li></ul><h4 class="font-semibold mb-2">기타 업데이트</h4><ul class="list-disc pl-5 text-sm mb-4 space-y-1"><li>로그라이크성 강화 : 적 생성 로직 및 스케일링 수정</li><li>플레이어 저장 데이터 암호화</li><li>서버 연동 (순위표 및 데이터 수집)</li><li>로딩화면 개선</li></ul><h4 class="font-semibold mb-2">v0.2.2</h4><ul class="list-disc pl-5 text-sm mb-4 space-y-1"><li>업그레이드 보상 문구 수정</li><li>TAB키(UI숨김) 기능 점수,시간 패널 과 연동</li></ul><h4 class="font-semibold mb-2">v0.2.3</h4><ul class="list-disc pl-5 text-sm mb-4 space-y-1"><li>최종점수 0 으로 표기되는 버그 수정</li><li>데이터 수집관련 버그 수정</li><li>복수의 화신 : 타워 데미지분석 이미지 오류 개선</li><li>웨이브 알림이 최우선으로 작용되도록 개선, 주요알림 우선순위 재설정</li><li>간헐적으로 상점 뽑기모션 오류로 인한 로직 개선</li><li>간헐적으로 타워버튼 비활성화 되는 버그 방어조치</li><li>무한모드 점수 등록 시 순위표 최신화 문제 개선</li><li>희생전략 특성 : 스킬버튼 관련 버그 수정</li><li>연쇄폭발 특성 : 하향</li><li>상점 뽑기 종류 추가</li></ul><h4 class="font-semibold mb-2">v0.2.4</h4><ul class="list-disc pl-5 text-sm mb-4 space-y-1"><li>파괴신의 석상 버그 수정</li><li>오류 추적 시스템 추가</li><li>신규 적 3종 추가</li><li>투사체 관련 타워 버그 개선 : 투사체가 남아 렉을 유발하는 문제</li><li>게임종료 후 로비에서 뽑기 시 멈추는 버그 개선</li><li>다량의 타워 설치시 소리 문제 개선</li></ul></div></div></div><div style="display:block"><div class="space-y-8"><div class="text-center mb-12"><h1 class="text-4xl font-bold mb-4">Roguelike Tower Defense</h1><div class="mt-4 flex justify-center space-x-4 mb-4"><span class="px-3 py-1 bg-blue-100 text-blue-800 rounded">#로그라이크</span><span class="px-3 py-1 bg-blue-100 text-blue-800 rounded">#타워 디펜스</span><span class="px-3 py-1 bg-blue-100 text-blue-800 rounded">#전략</span></div></div><div class="mb-8 bg-white rounded-lg shadow p-6"><h2 class="text-2xl font-bold mb-4">개발 도구</h2><ul class="list-disc pl-5 text-sm mb-4"><li>엔진 : unity</li><li>언어 : C#</li><li>디자인 도구 : Aseprite</li><li>백엔드 서비스 : PlayFab</li></ul><div class="grid grid-cols-4 gap-4 w-1/2"><div class="rounded-lg overflow-hidden"><img src="/towerdefense-portfolio/icon/unity.png" class="h-full w-full object-cover"/></div><div class="rounded-lg overflow-hidden"><img src="/towerdefense-portfolio/icon/csharp.png" class="h-full w-full object-cover"/></div><div class="rounded-lg overflow-hidden"><img src="/towerdefense-portfolio/icon/ase.png" class="h-full w-full object-cover"/></div><div class="rounded-lg overflow-hidden"><img src="/towerdefense-portfolio/icon/PlayFab.jpg" class="h-full w-full object-cover"/></div></div></div><div class="mb-8 bg-white rounded-lg shadow p-6"><h2 class="text-2xl font-bold mb-4">프로젝트 목표 및 설계 철학</h2><div class="space-y-3 text-sm text-gray-700 leading-relaxed"><p>이 프로젝트는 Unity와 C#에 대한 깊은 이해를 바탕으로, 단순한 기능 구현을 넘어 <b>상용화 수준의 게임 개발 파이프라인 전체를 경험</b>하는 것을 목표로 했습니다. 특히 PlayFab과 같은 외부 BaaS(Backend as a Service)를 연동하여 로그인, 랭킹, 데이터 분석, 원격 오류 수집 등 실시간 서비스에 필요한 핵심 백엔드 기능을 직접 구현하고자 했습니다.</p><p>설계 철학의 핵심은<!-- --> <b>`확장성`, `데이터 기반 디자인`, `코드 중복성 최소화`</b>입니다. `타워`, `적`, `장비` 등 핵심 요소를 모두 모듈화하고,<b>상속(Inheritance) 구조</b>를 적극적으로 활용했습니다. 예를 들어, 모든 타워 무기의 공통 로직을 담은 `TowerWeapon`이라는 기반 클래스를 설계하고, `WeaponArrow`, `WeaponDefault` 등이 이를 상속받아 각 무기 고유의 공격 방식만 구현하도록 하여 코드의 재사용성과 유지보수성을 높였습니다. 또한, 밸런스 데이터는 `ScriptableObject`및 Json 파일로 관리하여 코드 수정 없이 유연한 업데이트가 가능한 시스템을 구축했습니다.</p></div></div><div class="mb-8 bg-white rounded-lg shadow p-6"><h2 class="text-2xl font-bold mb-4">기술 요약</h2><p class="text-sm text-gray-700 leading-relaxed">이번 프로젝트는 <b>모듈형 구조와 이벤트 기반 설계</b>를 통해 유지보수성과 확장성을 극대화한 2D 로그라이크 타워 디펜스 게임입니다. 타워와 스킬은 <b>State 패턴</b>을 적용하여 행동(탐색·공격)을 명확히 분리하였고, 주요 UI는 <b>이벤트 기반 갱신</b>으로 처리되어 불필요한 연산을 최소화했습니다.</p><p class="text-sm text-gray-700 leading-relaxed mt-2">또한, <b>절차적 맵 생성 알고리즘</b>을 직접 설계하여 매번 새로운 플레이 경험을 제공하며, <b>데이터 기반 설계</b>로 리플레이성과 유지보수성을 높였습니다. 특히, `Time.timeScale` 오염으로 인한 게임 멈춤 현상, 다중 오브젝트 환경에서의 사운드 병목 현상 등 복합적인 버그들을 <b>정확한 원인 분석과 메모리 관리, 방어 코드 설계</b>를 통해 해결하여 프로그램의 안정성을 크게 향상시켰습니다.</p></div><div class="mb-8 bg-white rounded-lg shadow p-6"><h2 class="text-2xl font-bold mb-4">주요 성과</h2><ul class="list-disc pl-5 space-y-2 text-sm"><li>오브젝트 풀링 적용 → 100개 투사체 타워 동시 발사에도 안정적인 프레임 유지</li><li>난이도/경로 절차적 맵 생성 시스템 구현으로 매 플레이마다 새로운 전략 변수 제공</li><li>모듈화된 Tower/Enemy/Skill 구조 설계로 신규 콘텐츠 추가 시 코드 변경 최소화</li><li>PlayFab 기반 글로벌 랭킹 연동 및 플레이어 데이터 수집·분석</li><li>이벤트 기반 UI 구조 설계로 UI와 게임 로직 간 의존성 최소화</li></ul></div><div class="mb-8 bg-white rounded-lg shadow p-6"><h2 class="text-2xl font-bold mb-4">게임 개요</h2><div class="grid grid-cols-2 gap-6"><div><h3 class="text-lg font-semibold mb-2">핵심 컨셉</h3><ul class="list-disc pl-5 space-y-2"><li>로그라이크 요소와 타워 디펜스의 결합</li><li>웨이브별 전략적 선택과 성장</li><li>장비 파밍과 난이도 강화</li></ul></div><div><h3 class="text-lg font-semibold mb-2">타겟 플레이어</h3><ul class="list-disc pl-5 space-y-2"><li>전략 게임을 선호하는 게이머</li><li>로그라이크 장르 팬층</li><li>낮은 난이도를 추구하는 유저</li></ul></div></div></div><div class="mb-8 bg-white rounded-lg shadow p-6"><h2 class="text-2xl font-bold mb-4">게임 흐름</h2><div class="grid md:grid-cols-2 gap-6"><div class="p-4 bg-gray-50 rounded-lg"><h3 class="font-semibold mb-2 text-lg text-center">대기실 흐름</h3><p class="text-xs text-center text-gray-600 mb-3">전략 준비 및 성장 단계</p><ol class="list-decimal list-inside space-y-2 text-sm"><li>획득한 장비를 확인하고 캐릭터에 장착</li><li>보유한 RCoin을 사용하여 상점에서 새로운 장비 뽑기</li><li>도전할 난이도 선택</li><li>준비 완료 후 게임 시작</li></ol></div><div class="p-4 bg-gray-50 rounded-lg"><h3 class="font-semibold mb-2 text-lg text-center">인게임 흐름</h3><p class="text-xs text-center text-gray-600 mb-3">전투와 랜덤성을 통한 성장 경험</p><ol class="list-decimal list-inside space-y-2 text-sm"><li><b>첫 웨이브 특성</b> 선택 (플레이 컨셉 결정)</li><li><b>[</b> 타워 건설 → 적 처치 → 재화 획득 <b>]</b> 전투 루프 반복</li><li>웨이브 클리어 시 제시되는 <b>랜덤 보상</b> 중 택 1 (전략 강화)</li><li>최종 웨이브 클리어 또는 패배</li><li>결과 확인 및 보상(장비) 획득 후 대기실 복귀</li></ol></div></div><div class="p-4 rounded-lg overflow-hidden shadow-lg grid grid-cols-2 gap-4"><div><img src="/towerdefense-portfolio/Desc/Lobby.png" class="w-full object-cover"/><figcaption class="text-center text-sm text-gray-600 mt-2">게임 로비 화면</figcaption></div><div><img src="/towerdefense-portfolio/Desc/IngameUI.png" class="w-full object-cover"/><figcaption class="text-center text-sm text-gray-600 mt-2">인게임 UI</figcaption></div></div></div><div class="mb-8 bg-white rounded-lg shadow p-6"><h2 class="text-2xl font-bold mb-4">핵심 시스템</h2><div class="space-y-8"><div><h3 class="text-lg font-semibold mb-4">타워 시스템</h3><div class="space-y-6"><div><h4 class="font-semibold mb-2">기본 설계 방향</h4><div class="grid grid-cols-2 gap-4"><div class="p-3 bg-blue-50 rounded"><p class="font-semibold">보스 몬스터 특화형</p><p class="text-sm">단일 타겟, 높은 데미지</p></div><div class="p-3 bg-blue-50 rounded"><p class="font-semibold">일반 몬스터 특화형</p><p class="text-sm">다중 타겟, 낮은 데미지</p></div><div class="p-3 bg-blue-50 rounded"><p class="font-semibold">근거리형 타워</p><p class="text-sm">낮은 사거리, 높은 데미지</p></div><div class="p-3 bg-blue-50 rounded"><p class="font-semibold">원거리형 타워</p><p class="text-sm">높은 사거리, 낮은 데미지</p></div></div></div><div><h4 class="font-semibold mb-4">타워 종류</h4><div class="space-y-6"><div><div class="p-4 bg-gray-50 rounded"><ul class="list-disc pl-5 space-y-2"><li>타워 생산 비용 : TC(TowerCost) 단위 / 인게임에서는 이미지로 표기</li><li>타워 공격 타입 : 물리형, 마법형, 복합형</li><li>타워의 업그레이드는 타워의 공격 타입에 따라 영향을 받음 (복합형은 두 종류의 업그레이드를 합계로 받음)</li></ul></div></div></div><div class="grid grid-cols-2 gap-4"><div class="p-4 bg-gray-50 rounded"><h4 class="font-semibold">기본 타워</h4><p class="text-sm text-gray-600">50TC / 복합형</p><p class="text-sm">기본적인 단일 공격 타워</p></div><div class="p-4 bg-gray-50 rounded"><h4 class="font-semibold">검사 타워</h4><p class="text-sm text-gray-600">70TC / 물리형</p><p class="text-sm">높은 공격 속도와 단일 데미지</p></div><div class="p-4 bg-gray-50 rounded"><h4 class="font-semibold">창술사 타워</h4><p class="text-sm text-gray-600">200TC / 물리형</p><p class="text-sm">최대 4개 대상 동시 공격</p></div><div class="p-4 bg-gray-50 rounded"><h4 class="font-semibold">궁수 타워</h4><p class="text-sm text-gray-600">130TC / 물리형</p><p class="text-sm">넓은 범위의 다중 공격</p></div><div class="p-4 bg-gray-50 rounded"><h4 class="font-semibold">레이저 타워</h4><p class="text-sm text-gray-600">120TC / 마법형</p><p class="text-sm">높은 DPS의 단일 타겟 공격</p></div><div class="p-4 bg-gray-50 rounded"><h4 class="font-semibold">사제 타워</h4><p class="text-sm text-gray-600">100TC / 마법형</p><p class="text-sm">적 방어력 감소 효과</p></div></div></div></div><div class="p-4 rounded-lg overflow-hidden shadow-lg"><div><img src="/towerdefense-portfolio/Desc/TowerButton.png" class="w-full object-cover"/></div></div></div><div><h3 class="text-lg font-semibold mb-4">스킬 시스템</h3><div class="space-y-6"><div><div class="p-4 bg-gray-50 rounded"><ul class="list-disc pl-5 space-y-2"><li>타워별 특수능력을 스킬패널에서 제공</li><li>SP 초기값 : 0, 최대값 : 200</li><li>웨이브 클리어 시 20 SP 자동 지급</li><li>모든 스킬 20 SP 소모</li><li>웨이브당 스킬별 1회 사용 제한</li></ul></div></div></div><div class="p-4 rounded-lg overflow-hidden shadow-lg"><div><img src="/towerdefense-portfolio/Desc/SkillButton.png" class="w-full object-cover"/></div></div></div><h3 class="text-lg font-semibold mb-4">웨이브 시스템</h3><div class="p-4 bg-gray-50 rounded"><div class="grid grid-cols-3 gap-4"><div class="p-4 bg-gray-50 rounded"><h4 class="font-semibold">일반 웨이브</h4><p class="text-sm">30마리 몬스터 출현</p></div><div class="p-4 bg-gray-50 rounded"><h4 class="font-semibold">네임드</h4><p class="text-sm">특정 웨이브 등장, 강화된 능력치</p></div><div class="p-4 bg-gray-50 rounded"><h4 class="font-semibold">보스</h4><p class="text-sm">최종웨이브 클리어 목표</p></div></div></div><div><h3 class="text-lg font-semibold mb-4">보상 시스템</h3><div class="space-y-4 mb-4"><div class="p-4 bg-gray-50 rounded"><h4 class="font-semibold mb-2">기본 보상</h4><p class="text-sm">웨이브 클리어 시 20 SP</p></div><div class="p-4 bg-gray-50 rounded"><h4 class="font-semibold mb-2">웨이브 처치 보상</h4><p class="text-sm">개별 적 1개체당 골드 보상, 웨이브 진행도에 따라 증가</p></div><div class="p-4 bg-gray-50 rounded"><h4 class="font-semibold mb-2">첫 웨이브 특성</h4><ul class="list-disc pl-5 text-sm space-y-1"><li>게임 시작 시 첫 웨이브에서 10가지 특성 중 2개 제시</li><li>1개 선택 시 게임 플레이 전반에 큰 영향</li><li>기존 웨이브 랜덤 보상과 연계</li></ul><div class="p-4 overflow-hidden"><div><img src="/towerdefense-portfolio/Desc/Perk.png" class="w-full object-cover"/></div></div></div><div class="p-4 bg-gray-50 rounded"><h4 class="font-semibold mb-2">선택형 추가 보상</h4><p class="text-sm mb-2">매 웨이브 종료 시 2개의 보상 중 1개 선택</p><p class="text-sm mb-2">2개의 보상은 중복 가능하다</p><p class="text-sm mb-2">개별 보상은 선택지, 수치 2개의 랜덤을 통해 확정된다</p><ul class="list-disc pl-5 text-sm space-y-1"><li>HP 회복 (최대 체력 상태에서는 등장 X)</li><li>SP 추가 20~60 포인트</li><li>골드 보상</li><li>랜덤 타워 자동 설치 (경로 주위 우선으로 설치)</li><li>무료 물리/마법 업그레이드</li></ul><div class="p-4 overflow-hidden"><div><img src="/towerdefense-portfolio/Desc/RandomReward.png" class="w-full object-cover"/></div></div></div></div><h3 class="text-lg font-semibold mb-4">난이도 &amp; 장비 시스템</h3><div class="space-y-4 mb-4"><div class="p-4 bg-gray-50 rounded"><h3 class="text-lg font-semibold mb-2">난이도 시스템</h3><ul class="list-disc pl-5 text-sm space-y-1"><li>대기실에서 난이도 선택 가능</li><li>적 체력, 골드, 웨이브 배율에 직접 영향</li><li>난이도 곡선 설계로 고난이도 플레이 지원</li><li>난이도에 비례한 장비등급 확률 조정</li></ul></div><div class="p-4 bg-gray-50 rounded"><h4 class="font-semibold mb-2">장비 시스템</h4><ul class="list-disc pl-5 text-sm space-y-1 mb-4"><li>장비 획득 및 장착 시스템</li><li>도감을 통한 장비 수집의 재미 제공</li><li>장신구 장착 시 특수 스킬 발동</li><li>웨이브 보상 및 난이도와 연계된 파밍</li><li>장비 파밍을 통한 높은 난이도를 도전</li><li>보스급 적 처치, 클리어 보상, 랜덤 보상 패널을 통한 획득처</li></ul><div><img src="/towerdefense-portfolio/Desc/WaitingRoom.png" class="w-full object-cover"/><figcaption class="text-center text-sm text-gray-600 mt-2">대기실 화면</figcaption></div><div><img src="/towerdefense-portfolio/Desc/Collect.png" class="w-full object-cover"/><figcaption class="text-center text-sm text-gray-600 mt-2">장비 도감</figcaption></div></div><div class="p-4 bg-gray-50 rounded"><h4 class="font-semibold mb-2">상점 시스템</h4><ul class="list-disc pl-5 text-sm space-y-1 mb-4"><li>장비 수집의 완화제</li><li>슬롯머신 애니메이션을 통한 뽑기효과</li><li>중복 장비 획득시 재화로 전환 (등급별 상이)</li><li>중복획득의 불쾌감 감소 및 뽑기의 재미 요소</li></ul><div class="p-4 overflow-hidden grid grid-cols-2 gap-4"><div><img src="/towerdefense-portfolio/Desc/Store1.png" class="w-full object-cover"/><figcaption class="text-center text-sm text-gray-600 mt-2">상점 UI</figcaption></div><div><img src="/towerdefense-portfolio/Desc/Store3.png" class="w-full object-cover"/><figcaption class="text-center text-sm text-gray-600 mt-2">뽑기 애니메이션1</figcaption></div><div><img src="/towerdefense-portfolio/Desc/StoreAnimation.gif" class="w-full object-cover"/><figcaption class="text-center text-sm text-gray-600 mt-2">뽑기 애니메이션2</figcaption></div><div><img src="/towerdefense-portfolio/Desc/Store4.png" class="w-full object-cover"/><figcaption class="text-center text-sm text-gray-600 mt-2">최종 획득 결과</figcaption></div></div></div></div></div></div><div class="p-4 bg-gray-50 rounded"><h3 class="text-lg font-semibold mb-4">무한모드 시스템</h3><ul class="list-disc pl-5 space-y-2 text-sm"><li><b>개방 조건 :</b> 일반 모드 100 난이도 클리어 시 개방</li><li><b>규칙 :</b><ul class="list-decimal pl-6 mt-1 space-y-1"><li>최종 웨이브가 없으며, 웨이브마다 2분의 제한 시간이 주어집니다.</li><li>적이 최종 지점에 도달해도 죽지 않고 출발 지점으로 순환합니다.</li><li>제한 시간 내에 모든 적을 처치하면 웨이브 클리어입니다.</li><li>시간 내에 적을 모두 처치하지 못하면 남은 적 하나당 HP가 1씩 감소합니다.</li><li>HP가 0이 되면 게임이 종료되고 최종 점수가 정산됩니다.</li></ul></li><li><b>점수 및 순위표 :</b><ul class="list-disc pl-6 mt-1 space-y-1"><li>클리어 점수, 맵 난이도 배율, 남은 시간을 합산하여 최종 점수가 결정됩니다.</li><li>최종 점수를 기준으로 상위 10명의 순위표(리더보드)에 등록할 수 있습니다.</li></ul></li><li><b>특수 기능 :</b> 데미지 분석 기능을 통해 타워별 데미지 기여도를 확인할 수 있습니다.</li></ul><div class="p-4 overflow-hidden grid grid-cols-2 gap-4"><div><img src="/towerdefense-portfolio/Desc/InfinityMode.png" class="w-full object-cover"/><figcaption class="text-center text-sm text-gray-600 mt-2">무한모드 활성화 UI</figcaption></div><div><img src="/towerdefense-portfolio/Desc/DamageMeter.png" class="w-full object-cover"/><figcaption class="text-center text-sm text-gray-600 mt-2">무한모드 데미지 분석 기능</figcaption></div><div><img src="/towerdefense-portfolio/Desc/IngameReaderBoard.png" class="w-full object-cover"/><figcaption class="text-center text-sm text-gray-600 mt-2">순위표</figcaption></div><div><img src="/towerdefense-portfolio/Desc/PlayFabReaderBoard.png" class="w-full object-cover"/><figcaption class="text-center text-sm text-gray-600 mt-2">PlayFab내 리더보드 데이터</figcaption></div></div></div></div><div class="mb-8 bg-white rounded-lg shadow p-6"><h2 class="text-2xl font-bold mb-4">기술적 특징</h2><div class="space-y-6"><div><h3 class="font-semibold mb-2">그래픽 &amp; UI</h3><div class="p-4 bg-gray-50 rounded"><ul class="list-disc pl-5 text-sm space-y-1"><li>픽셀 아트 그래픽 스타일</li><li>UI 간소화 설계</li><li>TAB 키를 통한 UI ON/OFF 기능</li></ul></div></div><div><h3 class="font-semibold mb-2">시스템 설계</h3><div class="p-4 bg-gray-50 rounded"><ul class="list-disc pl-5 text-sm space-y-3"><li><b>모듈형 타워 시스템 (State 패턴)</b> : `IWeaponState` 인터페이스를 기반으로 타워의 행동(탐색, 공격)을 명확하게 분리하여 확장성을 높였습니다.<div class="mt-3 space-y-4"><div class="bg-gray-900 text-gray-100 rounded-lg shadow"><button type="button" aria-expanded="false" class="flex w-full items-center justify-between px-4 py-3 text-left text-sm font-medium focus:outline-none focus-visible:ring-2 focus-visible:ring-indigo-500"><span>/Tower/WeaponStates/IWeaponState.cs - 타워 상태 인터페이스</span><span aria-hidden="true" class="transition-transform duration-200 ">▶</span></button></div></div></li><li><b>이벤트 기반 UI 업데이트</b> : `UIEventManager`를 통해 게임 데이터와 UI를 분리, 데이터 변경 시 UI가 실시간으로 반응하도록 설계하여 유지보수성을 강화했습니다.<div class="mt-3 space-y-4"><div class="bg-gray-900 text-gray-100 rounded-lg shadow"><button type="button" aria-expanded="false" class="flex w-full items-center justify-between px-4 py-3 text-left text-sm font-medium focus:outline-none focus-visible:ring-2 focus-visible:ring-indigo-500"><span>/UI/UIEventManager.cs - 이벤트 중앙 관리</span><span aria-hidden="true" class="transition-transform duration-200 ">▶</span></button></div></div></li><li><b>오브젝트 풀링</b> : 성능 최적화를 위해 적, 발사체 등 반복 생성되는 오브젝트를 재활용하는 시스템을 구현했습니다.<div class="mt-3 space-y-4"><div class="bg-gray-900 text-gray-100 rounded-lg shadow"><button type="button" aria-expanded="false" class="flex w-full items-center justify-between px-4 py-3 text-left text-sm font-medium focus:outline-none focus-visible:ring-2 focus-visible:ring-indigo-500"><span>/System/ObjectPool.cs</span><span aria-hidden="true" class="transition-transform duration-200 ">▶</span></button></div></div><div class="p-4 overflow-hidden grid grid-cols-2 gap-4"><div><img src="/towerdefense-portfolio/Desc/Pooling1.png" class="w-full object-cover"/><figcaption class="text-center text-sm text-gray-600 mt-2">풀링 성능 테스트 1 (148.19 FPS)</figcaption></div><div><img src="/towerdefense-portfolio/Desc/Pooling2.png" class="w-full object-cover"/><figcaption class="text-center text-sm text-gray-600 mt-2">풀링 성능 테스트 2 (175.48 FPS)</figcaption></div></div></li><li><b>중앙 집중형 사운드 관리</b> : `SoundManager`를 통해 BGM, SFX를 관리하며, 여러 개의 지속 사운드를 독립적으로 제어하는 기능을 구현했습니다.<div class="mt-3 space-y-4"><div class="bg-gray-900 text-gray-100 rounded-lg shadow"><button type="button" aria-expanded="false" class="flex w-full items-center justify-between px-4 py-3 text-left text-sm font-medium focus:outline-none focus-visible:ring-2 focus-visible:ring-indigo-500"><span>/System/SoundManager.cs - PlayBGM &amp; PlaySFX</span><span aria-hidden="true" class="transition-transform duration-200 ">▶</span></button></div></div></li><li><b>애니메이션 재사용성</b> : `Animator Override Controller`를 활용하여 모든 타워가 하나의 로직을 공유하되, 각 타워의 애니메이션 클립만 교체하도록 설계하여 효율성을 높였습니다.</li><li><b>데이터 기반 설계</b> : `ScriptableObject`를 활용하여 타워 밸런스를 코드 수정 없이 쉽게 조절할 수 있도록 설계했습니다.</li><li><b>절차적 맵 생성 및 난이도 정량화 시스템</b><ul class="list-decimal pl-6 mt-1 space-y-1 text-xs"><li><b>경로 생성 :</b> `RandomPathGenerator.cs`를 통해 매 게임 시작 시 새로운 적 이동 경로를 동적으로 생성하며, 생성된 경로의 유효성을 검사하여 항상 완주 가능한 맵을 보장합니다.</li><li><b>난이도 계산 :</b> 생성된 맵의 경로 길이, 꺾이는 횟수, 경로 간 간격 등 세 가지 요소를 가중치에 따라 조합하여 난이도를 객관적인 수치로 평가하는 `MapDifficulty.cs`를 설계했습니다.</li><li><b>시각화 :</b> 생성된 경로 데이터를 기반으로 `MapGenerator.cs`가 Unity의 `Tilemap`을 이용해 길, 코너, 성 등의 타일을 배치하고, 플레이어의 진행도에 따라 다양한 맵 테마가 무작위로 적용되도록 구현했습니다.</li></ul><div class="mt-3 space-y-4"><div class="bg-gray-900 text-gray-100 rounded-lg shadow"><button type="button" aria-expanded="false" class="flex w-full items-center justify-between px-4 py-3 text-left text-sm font-medium focus:outline-none focus-visible:ring-2 focus-visible:ring-indigo-500"><span>/Map/RandomPathGenerator.cs - 경로 생성 일부</span><span aria-hidden="true" class="transition-transform duration-200 ">▶</span></button></div><div class="bg-gray-900 text-gray-100 rounded-lg shadow"><button type="button" aria-expanded="false" class="flex w-full items-center justify-between px-4 py-3 text-left text-sm font-medium focus:outline-none focus-visible:ring-2 focus-visible:ring-indigo-500"><span>/Map/MapGenerator.cs - 경로를 따라 맵 타일 전시</span><span aria-hidden="true" class="transition-transform duration-200 ">▶</span></button></div></div><div class="p-4 overflow-hidden grid grid-cols-2 gap-4"><div><img src="/towerdefense-portfolio/Desc/RandomMap1.png" class="w-full object-cover"/></div><div><img src="/towerdefense-portfolio/Desc/RandomMap2.png" class="w-full object-cover"/></div><div><img src="/towerdefense-portfolio/Desc/RandomMap3.png" class="w-full object-cover"/></div></div></li><li><b>이벤트 기반 UI 갱신</b> : 장비 장착, 보상 선택 등 주요 이벤트를 이벤트 리스너 기반으로 처리하여, 불필요한 Update 호출을 줄이고 퍼포먼스를 개선했습니다.</li><li><b>웨이브 랜덤 보상 / 첫 웨이브 특성 시스템</b> : 선택형 보상 패널과 첫 웨이브 특성 선택 시스템을 통합하여, 게임 초반 전략성을 강화하고 플레이 전체에 즉각 반영되도록 설계했습니다.<div class="mt-3 space-y-4"><div class="bg-gray-900 text-gray-100 rounded-lg shadow"><button type="button" aria-expanded="false" class="flex w-full items-center justify-between px-4 py-3 text-left text-sm font-medium focus:outline-none focus-visible:ring-2 focus-visible:ring-indigo-500"><span>/System/WeightedRandomReward.cs - 웨이브 랜덤 보상</span><span aria-hidden="true" class="transition-transform duration-200 ">▶</span></button></div></div></li><li><b>타워 및 장비 스킬 고도화</b><ul class="pl-6 mt-1 space-y-3"><li>- 타워 데이터와 스킬 데이터를 한쌍으로 TowerArchetype로 통합<div class="mt-3 space-y-4"><div class="bg-gray-900 text-gray-100 rounded-lg shadow"><button type="button" aria-expanded="false" class="flex w-full items-center justify-between px-4 py-3 text-left text-sm font-medium focus:outline-none focus-visible:ring-2 focus-visible:ring-indigo-500"><span>/Data/Models/TowerArchetype.cs - 타워 &amp; 스킬 데이터 통합관리</span><span aria-hidden="true" class="transition-transform duration-200 ">▶</span></button></div></div></li><li>- 장비 특수 스킬을 SpecialSkillBase를 기반으로 상속받아 기능 구현<div class="mt-3 space-y-4"><div class="bg-gray-900 text-gray-100 rounded-lg shadow"><button type="button" aria-expanded="false" class="flex w-full items-center justify-between px-4 py-3 text-left text-sm font-medium focus:outline-none focus-visible:ring-2 focus-visible:ring-indigo-500"><span>/Data/SpecialSkillBase.cs - 장비 특수 스킬 추상 클래스</span><span aria-hidden="true" class="transition-transform duration-200 ">▶</span></button></div></div></li></ul></li><li><b>맵/적 랜덤성 추가</b> : 맵과 적 스폰 정보를 데이터 랜덤성 추가 설계로 리플레이성과 유지보수성을 크게 강화했습니다.<div class="mt-3 space-y-4"><div class="bg-gray-900 text-gray-100 rounded-lg shadow"><button type="button" aria-expanded="false" class="flex w-full items-center justify-between px-4 py-3 text-left text-sm font-medium focus:outline-none focus-visible:ring-2 focus-visible:ring-indigo-500"><span>/Map/MapGenerator.cs - 맵 타일셋 랜덤 생성</span><span aria-hidden="true" class="transition-transform duration-200 ">▶</span></button></div></div></li><li><b>사운드 및 해상도 대응</b> : 사운드 볼륨 정규화 및 1280~1600 해상도 대응 UI를 구현하고, 사운드매니저를 통해 관리 편의성과 확장성을 높였습니다.</li><li><b>데이터 관리 시스템 (암호화 및 마이그레이션)</b><p class="pl-4 text-xs">`GameDataManager.cs`를 통해 플레이어의 저장 데이터를 XOR 암호화하여 로컬 파일 변조를 방지했습니다. 또한, 과거 버전(암호화 미적용)의 세이브 파일을 불러올 경우, 자동으로 최신 암호화 버전으로 변환 후 저장하는 데이터 마이그레이션 기능을 구현하여 안정성을 높였습니다.</p><div class="mt-3 space-y-4"><div class="bg-gray-900 text-gray-100 rounded-lg shadow"><button type="button" aria-expanded="false" class="flex w-full items-center justify-between px-4 py-3 text-left text-sm font-medium focus:outline-none focus-visible:ring-2 focus-visible:ring-indigo-500"><span>/System/GameDataManager.cs - 암호화 및 마이그레이션</span><span aria-hidden="true" class="transition-transform duration-200 ">▶</span></button></div></div></li><li><b>툴팁 시스템 : 툴팁을 통한 유저 편의적인 UI 제공</b><p class="pl-4 text-xs">툴팁이 필요한 객체에 `TooltipTrigger.cs` 컴포넌트를 이용하여 정보제공</p><div class="p-4 overflow-hidden grid grid-cols-2 gap-4"><div><img src="/towerdefense-portfolio/Desc/Tooltip1.png" class="w-full object-cover"/><figcaption class="text-center text-sm text-gray-600 mt-2">툴팁 예시1 (타워 정보)</figcaption></div><div><img src="/towerdefense-portfolio/Desc/Tooltip3.png" class="w-full object-cover"/><figcaption class="text-center text-sm text-gray-600 mt-2">툴팁 예시2 (특수 장비 인게임 정보 실시간 표기)</figcaption></div><div><img src="/towerdefense-portfolio/Desc/Tooltip2.png" class="w-full object-cover"/><figcaption class="text-center text-sm text-gray-600 mt-2">툴팁 예시3 (장비 옵션)</figcaption></div><div><img src="/towerdefense-portfolio/Desc/Tooltip4.png" class="w-full object-cover"/><figcaption class="text-center text-sm text-gray-600 mt-2">툴팁 예시4 (도감에서 장비 옵션)</figcaption></div></div></li><li><b>툴팁 시스템 통합</b> : TooltipManager와 TooltipTrigger를 기반으로 장비, 타워, 스킬에 마우스 오버 시 실시간 툴팁을 표시하여 UI 일관성과 직관성을 강화했습니다.<div class="mt-3 space-y-4"><div class="bg-gray-900 text-gray-100 rounded-lg shadow"><button type="button" aria-expanded="false" class="flex w-full items-center justify-between px-4 py-3 text-left text-sm font-medium focus:outline-none focus-visible:ring-2 focus-visible:ring-indigo-500"><span>/System/TooltipManager.cs - 툴팁의 실질적인 표시를 담당</span><span aria-hidden="true" class="transition-transform duration-200 ">▶</span></button></div><div class="bg-gray-900 text-gray-100 rounded-lg shadow"><button type="button" aria-expanded="false" class="flex w-full items-center justify-between px-4 py-3 text-left text-sm font-medium focus:outline-none focus-visible:ring-2 focus-visible:ring-indigo-500"><span>/UI/TooltipTrigger.cs - 객체의 컴포넌트로 추가하여 툴팁 정보를 저장 및 이벤트 감지</span><span aria-hidden="true" class="transition-transform duration-200 ">▶</span></button></div></div></li><li><b>PlayFab을 통한 데이터 수집</b> : 전투 데이터 및 에러 데이터 수집<div class="p-4 overflow-hidden grid grid-cols-2 gap-4"><div><img src="/towerdefense-portfolio/Desc/PlayFabCombatData.png" class="w-full object-cover"/><figcaption class="text-center text-sm text-gray-600 mt-2">PlayFab을 통한 전투 데이터 수집</figcaption></div><div><img src="/towerdefense-portfolio/Desc/PlayFabError.png" class="w-full object-cover"/><figcaption class="text-center text-sm text-gray-600 mt-2">PlayFab 을 통한 에러 데이터 수집 쿼리</figcaption></div></div></li></ul></div></div></div></div><div class="mb-8 bg-white rounded-lg shadow p-6"><h2 class="text-2xl font-bold mb-4">게임 디자인</h2><div class="space-y-6"><div><div class="grid gap-4"><div class="p-4 bg-gray-50 rounded"><h4 class="font-semibold mb-2">캐릭터</h4><ul class="list-disc pl-5 text-sm"><li>타워 및 몬스터 캐릭터 픽셀 아트 제작</li><li><b>타워 애니메이션</b> : 모든 타워의 대기(Idle) 및 공격(Attack) 애니메이션을 구현</li></ul><div class="p-4 rounded-lg overflow-hidden shadow-lg grid grid-cols-8"><img src="/towerdefense-portfolio/character/CharacterBase01.png" class="w-full object-cover"/><img src="/towerdefense-portfolio/character/WarriorTower01.png" class="w-full object-cover"/><img src="/towerdefense-portfolio/character/SpearTower01.png" class="w-full object-cover"/><img src="/towerdefense-portfolio/character/ArcherTower01.png" class="w-full object-cover"/><img src="/towerdefense-portfolio/character/LaserTower01.png" class="w-full object-cover"/><img src="/towerdefense-portfolio/character/BuffTower01.png" class="w-full object-cover"/><img src="/towerdefense-portfolio/character/WarriorTower02.png" class="w-full object-cover"/><img src="/towerdefense-portfolio/character/WarriorTower03.png" class="w-full object-cover"/></div><div class="p-4 rounded-lg overflow-hidden shadow-lg grid grid-cols-3"><img src="/towerdefense-portfolio/character/CharacterBaseAnim.png" class="w-full object-cover"/><img src="/towerdefense-portfolio/character/WarriorTowerAnim.png" class="w-full object-cover"/><img src="/towerdefense-portfolio/character/SpearTowerAnim.png" class="w-full object-cover"/><img src="/towerdefense-portfolio/character/ArcherTowerAnim.png" class="w-full object-cover"/><img src="/towerdefense-portfolio/character/BuffTowerAnim.png" class="w-full object-cover"/><img src="/towerdefense-portfolio/character/LaserTowerAnim.png" class="w-full object-cover"/><img src="/towerdefense-portfolio/character/AvatarOfVengeance.png" class="w-full object-cover"/><img src="/towerdefense-portfolio/character/CommanderFlag.png" class="w-full object-cover"/></div></div><div class="p-4 bg-gray-50 rounded"><h4 class="font-semibold mb-2">아이콘</h4><ul class="list-disc pl-5 text-sm"><li>타워의 특수능력에 부합하는 스킬 아이콘 제작</li><li>동적인 상황의 경우 필요에따라 애니메이션으로 제작하거나 Unity에서 구현</li></ul><div class="p-4 rounded-lg overflow-hidden shadow-lg grid grid-cols-8"><img src="/towerdefense-portfolio/UI/SkillFist.png" class="w-full object-cover"/><img src="/towerdefense-portfolio/UI/SkillSlow.png" class="w-full object-cover"/><img src="/towerdefense-portfolio/UI/ArrowRain.png" class="w-full object-cover"/><img src="/towerdefense-portfolio/UI/SkillThunder.png" class="w-full object-cover"/><img src="/towerdefense-portfolio/UI/SkillDamageUp.png" class="w-full object-cover"/></div><div class="p-4 rounded-lg overflow-hidden shadow-lg"><img src="/towerdefense-portfolio/UI/SkillSpearLanding.png" class="w-full object-cover"/></div></div><div class="p-4 bg-gray-50 rounded"><h4 class="font-semibold mb-2">맵(타일셋)</h4><ul class="list-disc pl-5 text-sm"><li>타워디펜스에 최적화된 경로를 가진 타일셋 제작</li><li>웨이브 시작 및 종료지점 제작</li><li>시각적인 요소를 추가해줄 꾸밈타일 제작</li></ul><div class="p-4 rounded-lg overflow-hidden shadow-lg grid grid-cols-4 gap-x-4"><img src="/towerdefense-portfolio/UI/Tileset.png" class="w-full object-cover"/><img src="/towerdefense-portfolio/UI/Tileset_Snow.png" class="w-full object-cover"/><img src="/towerdefense-portfolio/UI/Tileset_Desert.png" class="w-full object-cover"/><img src="/towerdefense-portfolio/UI/Tileset_Magma.png" class="w-full object-cover"/></div></div><div class="p-4 bg-gray-50 rounded"><h4 class="font-semibold mb-2">오브젝트</h4><ul class="list-disc pl-5 text-sm"><li>맵에 필요한 오브젝트</li><li>투사체와 같은 추가 디자인 요소</li></ul><div class="p-4 rounded-lg overflow-hidden shadow-lg grid grid-cols-8"><img src="/towerdefense-portfolio/UI/Arrow.png" class="w-full object-cover"/><img src="/towerdefense-portfolio/UI/Stone.png" class="w-full object-cover"/></div></div><div class="p-4 bg-gray-50 rounded"><h4 class="font-semibold mb-2">장비</h4><ul class="list-disc pl-5 text-sm"><li>수집용 장비 이미지 (일부)</li></ul><div class="p-4 rounded-lg overflow-hidden shadow-lg grid grid-cols-12"><img src="/towerdefense-portfolio/Equipment/accessory_avatar_of_vengeance.png" class="w-full object-cover"/><img src="/towerdefense-portfolio/Equipment/accessory_drum_of_battle.png" class="w-full object-cover"/><img src="/towerdefense-portfolio/Equipment/accessory_heart_of_life_reversal.png" class="w-full object-cover"/><img src="/towerdefense-portfolio/Equipment/accessory_vitality_doll.png" class="w-full object-cover"/><img src="/towerdefense-portfolio/Equipment/armor_berserker_cuirass.png" class="w-full object-cover"/><img src="/towerdefense-portfolio/Equipment/armor_immortal_cuirass.png" class="w-full object-cover"/><img src="/towerdefense-portfolio/Equipment/armor_shadow_lord_armor.png" class="w-full object-cover"/><img src="/towerdefense-portfolio/Equipment/armor_starlight_robe.png" class="w-full object-cover"/><img src="/towerdefense-portfolio/Equipment/boot_atlas_steps.png" class="w-full object-cover"/><img src="/towerdefense-portfolio/Equipment/boot_dragon_roar.png" class="w-full object-cover"/><img src="/towerdefense-portfolio/Equipment/boot_ghost_boots.png" class="w-full object-cover"/><img src="/towerdefense-portfolio/Equipment/boot_stormwing_boots.png" class="w-full object-cover"/><img src="/towerdefense-portfolio/Equipment/glove_meteor_gloves.png" class="w-full object-cover"/><img src="/towerdefense-portfolio/Equipment/glove_shadow_woven_gloves.png" class="w-full object-cover"/><img src="/towerdefense-portfolio/Equipment/glove_time_warp_gloves.png" class="w-full object-cover"/><img src="/towerdefense-portfolio/Equipment/glove_titan_gauntlets.png" class="w-full object-cover"/><img src="/towerdefense-portfolio/Equipment/helmet_ancient_dragon_skull.png" class="w-full object-cover"/><img src="/towerdefense-portfolio/Equipment/helmet_crown_of_dominion.png" class="w-full object-cover"/><img src="/towerdefense-portfolio/Equipment/helmet_shadow_tracker_helmet.png" class="w-full object-cover"/><img src="/towerdefense-portfolio/Equipment/helmet_silver_helmet.png" class="w-full object-cover"/><img src="/towerdefense-portfolio/Equipment/weapon_bloodlust.png" class="w-full object-cover"/><img src="/towerdefense-portfolio/Equipment/weapon_divine_punishment_bow.png" class="w-full object-cover"/><img src="/towerdefense-portfolio/Equipment/weapon_rune_blade.png" class="w-full object-cover"/><img src="/towerdefense-portfolio/Equipment/weapon_world_tree_staff.png" class="w-full object-cover"/></div></div></div></div></div></div><div class="mb-8 bg-white rounded-lg shadow p-6"><h2 class="text-2xl font-bold mb-4">게임 음악</h2><ul class="list-disc pl-5 grid grid-cols-2 items-start gap-x-8 gap-y-5 text-sm"><li>타이틀<audio src="/towerdefense-portfolio/audio/SFX_BGM_MainTitle.mp3" preload="metadata" class="mt-2" controls=""></audio></li><li>초원 맵<audio src="/towerdefense-portfolio/audio/BGM_Game_Default.wav" preload="metadata" class="mt-2" controls=""></audio></li><li>눈 맵<audio src="/towerdefense-portfolio/audio/BGM_Game_Snow.wav" preload="metadata" class="mt-2" controls=""></audio></li><li>사막 맵<audio src="/towerdefense-portfolio/audio/BGM_Game_Desert.mp3" preload="metadata" class="mt-2" controls=""></audio></li><li>마그마 맵<audio src="/towerdefense-portfolio/audio/BGM_Game_Magma.mp3" preload="metadata" class="mt-2" controls=""></audio></li><li>클리어<audio src="/towerdefense-portfolio/audio/BGM_ClearScene.mp3" preload="metadata" class="mt-2" controls=""></audio></li></ul></div></div></div><div style="display:none"><div class="space-y-8"><div class="bg-white rounded-lg shadow p-6"><h2 class="text-2xl font-bold mb-4">통합 개발 일지 (Beta_v0.2.x)</h2><p class="text-sm mb-4">Beta v0.2.1부터 v0.2.4까지의 주요 업데이트 및 버그 수정 내역입니다.</p><div class="space-y-8 text-sm"><div class="p-4 border-l-4 border-gray-400"><h3 class="font-semibold text-lg mb-2">v0.2.4</h3><div class="space-y-4"><div><h4 class="font-semibold mb-1">주요 버그 수정</h4><ul class="list-disc pl-5 space-y-3"><li><b><span class="text-red-600">■</span> 게임 종료 후 상점 멈춤 버그 해결:</b><p class="pl-4 text-xs">문제: 게임 플레이 중 변경된 Time.timeScale(0 또는 4)이 씬 전환 후에도 유지되어, 상점 애니메이션이 무한 루프에 빠지거나 비정상적으로 재생됨. → 해결: 로비 씬 진입 시 Time.timeScale을 1로 강제 초기화하는 로직을 추가하여 문제 해결.</p></li><li><b><span class="text-red-600">■</span> 다중 오브젝트 환경 최적화 (사운드):</b><p class="pl-4 text-xs">문제: 다수의 타워가 동시에 공격 시 효과음(SFX)이 끊기거나 작아지는 현상 발생. → 해결: 오디오 소스 풀링(Pooling) 및 재생 조절 기법을 도입하여 시스템 안정성과 사운드 품질을 동시에 개선.</p><div class="mt-3 space-y-4"><div class="bg-gray-900 text-gray-100 rounded-lg shadow"><button type="button" aria-expanded="false" class="flex w-full items-center justify-between px-4 py-3 text-left text-sm font-medium focus:outline-none focus-visible:ring-2 focus-visible:ring-indigo-500"><span>/System/SoundManager.cs – 초기화 &amp; 풀링</span><span aria-hidden="true" class="transition-transform duration-200 ">▶</span></button></div></div></li><li><b><span class="text-red-600">■</span> `파괴신의 석상` 스킬 비정상 종료 버그 해결:</b><p class="pl-4 text-xs">문제: 스킬 발동 시 `foreach`로 적 리스트를 순회하는 도중, 다른 코드에서 해당 리스트를 수정하여 `InvalidOperationException` 오류 발생. → 해결: 반복문 시작 전, 원본 리스트의 `복사본`을 만들어 순회하도록 변경하여 오류를 원천적으로 방지.</p><div class="mt-3 space-y-4"><div class="bg-gray-900 text-gray-100 rounded-lg shadow"><button type="button" aria-expanded="false" class="flex w-full items-center justify-between px-4 py-3 text-left text-sm font-medium focus:outline-none focus-visible:ring-2 focus-visible:ring-indigo-500"><span>/Data/SpecialSkills/StatueOfDestructionGod.cs</span><span aria-hidden="true" class="transition-transform duration-200 ">▶</span></button></div></div></li><li><b>투사체 터널링 문제 해결:</b><p class="pl-4 text-xs">문제: 렉 발생 시 빠른 투사체가 적을 관통하는 현상. → 해결: 투사체 Prefab의 Rigidbody 2D 컴포넌트에서 Collision Detection을 `Discrete`에서 `Continuous`로 변경하여 해결.</p></li></ul></div><div><h4 class="font-semibold mb-1">추가</h4><ul class="list-disc pl-5 space-y-1"><li><b>오류 추적 시스템:</b> `ExceptionReporter.cs`를 추가하여, 게임 플레이 중 발생하는 치명적인 오류(Exception)를 PlayFab으로 자동 전송하는 기능 구현.<div class="mt-3 space-y-4"><div class="bg-gray-900 text-gray-100 rounded-lg shadow"><button type="button" aria-expanded="false" class="flex w-full items-center justify-between px-4 py-3 text-left text-sm font-medium focus:outline-none focus-visible:ring-2 focus-visible:ring-indigo-500"><span>/Network/ExceptionReporter.cs</span><span aria-hidden="true" class="transition-transform duration-200 ">▶</span></button></div></div></li><li>신규 스프라이트를 이용한 신규 `적` 3종 추가.</li><li><b>리소스 최적화:</b> 로딩 씬에 `Resources.UnloadUnusedAssets` 및 `GC.Collect`를 호출하는 로직을 추가하여, 게임 세션 종료 후 메모리를 정리하도록 개선.<div class="mt-3 space-y-4"><div class="bg-gray-900 text-gray-100 rounded-lg shadow"><button type="button" aria-expanded="false" class="flex w-full items-center justify-between px-4 py-3 text-left text-sm font-medium focus:outline-none focus-visible:ring-2 focus-visible:ring-indigo-500"><span>/System/LoadingSceneController.cs - 메모리 정리</span><span aria-hidden="true" class="transition-transform duration-200 ">▶</span></button></div></div></li></ul></div></div></div><div class="p-4 border-l-4 border-green-500 bg-green-50"><h3 class="font-semibold text-lg mb-2 text-green-800">v0.2.3 (주요 안정성 업데이트)</h3><div class="space-y-4"><div><h4 class="font-semibold mb-1">주요 버그 수정</h4><ul class="list-disc pl-5 space-y-3"><li><b>상점 뽑기 기능 안정화:</b><p class="pl-4 text-xs">문제: 뽑기 애니메이션 중 `Resources.Load`의 반복 호출로 인한 성능 저하 및 게임 멈춤 현상. → 해결: 애니메이션 시작 전 필요한 모든 아이콘을 미리 불러오는 `Preloading` 방식을 적용하고, `try-finally` 구문을 추가하여 안정성 강화.</p><div class="mt-3 space-y-4"><div class="bg-gray-900 text-gray-100 rounded-lg shadow"><button type="button" aria-expanded="false" class="flex w-full items-center justify-between px-4 py-3 text-left text-sm font-medium focus:outline-none focus-visible:ring-2 focus-visible:ring-indigo-500"><span>/UI/ShopManager.cs - 아이콘 프리로딩</span><span aria-hidden="true" class="transition-transform duration-200 ">▶</span></button></div></div></li><li><b>`희생 전략` 특성 관련 버그 수정:</b><ul class="list-disc pl-6 space-y-1"><li>특성을 선택하지 않아도 타워 버튼이 비활성화되는 현상 해결 (방어 코드 추가).</li><li>비활성화된 스킬이 다음 웨이브에 다시 활성화되는 문제 해결.</li></ul></li></ul></div><div><h4 class="font-semibold mb-1">UI / UX 개선</h4><ul class="list-disc pl-5 space-y-2"><li><b>웨이브 알림 우선순위:</b> 웨이브 시작 알림이 다른 알림을 중단하고 즉시 최상단에 표시되도록 개선.</li><li><b>무한모드 순위표:</b> 점수 등록 시 서버 응답 완료 후 순위표가 새로고침되도록 콜백 로직을 수정하고, 과정 동안 로딩 화면을 표시하여 UX 개선.</li><li><b>데미지 미터기:</b> 특수 스킬로 소환된 타워의 아이콘이 정상적으로 표시되도록 조회 로직 개선. ( 특수타워 아이콘 형식을 일반 타워와 통일 )</li></ul></div><div><h4 class="font-semibold mb-1">데이터 및 분석</h4><ul class="list-disc pl-5 space-y-2"><li><b>최종 점수 0점 표시:</b> 일반 모드 클리어 시 점수 계산 순서 오류로 최종 점수가 0으로 표시되던 버그 수정.</li><li><b>PlayFab 분석 데이터 누락:</b> `scoreDetails`, `finalWaveEnemyInfo` 등 주요 플레이 로그가 누락되던 문제 해결. (적 정보 수집 방식을 `실시간 조회`에서 `웨이브 샘플 저장` 방식으로 변경)</li><div class="mt-3 space-y-4"><div class="bg-gray-900 text-gray-100 rounded-lg shadow"><button type="button" aria-expanded="false" class="flex w-full items-center justify-between px-4 py-3 text-left text-sm font-medium focus:outline-none focus-visible:ring-2 focus-visible:ring-indigo-500"><span>/System/GameManager.cs - 적 &amp; 최종 데이터 수집</span><span aria-hidden="true" class="transition-transform duration-200 ">▶</span></button></div></div></ul></div><div><h4 class="font-semibold mb-1">밸런스 및 기타</h4><ul class="list-disc pl-5 space-y-1"><li>`연쇄 폭발` 특성 성능 하향 조정.</li><li>상점에 고급, 희귀 등급의 신규 뽑기 상품 추가.</li><li>`복수의 화신` 타워 데미지 분석 이미지 오류 개선.</li></ul></div></div></div><div class="p-4 border-l-4 border-gray-300"><h3 class="font-semibold text-lg mb-2">v0.2.2</h3><ul class="list-disc pl-5 space-y-1"><li>물리/마법 업그레이드 보상 선택 시 문구 수정.</li><li>TAB 키(UI숨김) 기능이 점수, 시간 패널과 연동되도록 개선.</li></ul></div><div class="p-4 border-l-4 border-blue-500 bg-blue-50"><h3 class="font-semibold text-lg mb-2 text-blue-800">Beta_v0.2.1 (주요 업데이트)</h3><div class="space-y-4"><div><h4 class="font-semibold mb-1">신규 콘텐츠: 무한모드</h4><ul class="list-disc pl-5 space-y-1"><li>최종 웨이브 없이, 제한 시간 내 적을 모두 처치하는 방식의 신규 모드 추가.</li><li>플레이 점수를 기록하는 `순위표` 기능 및 <b>Azure PlayFab</b> <!-- -->서버 연동.</li><li>인게임 `데미지 분석` 기능 추가.</li></ul></div><div><h4 class="font-semibold mb-1">주요 시스템</h4><ul class="list-disc pl-5 space-y-1"><li><b>상점 및 재화:</b> 중복 장비 획득 시 `RCoin`을 지급하고, 이를 사용해 장비를 뽑는 상점 시스템 추가.</li><li><b>데이터 수집:</b> 유저 플레이 데이터(클리어 여부, 장비, 타워 통계 등) 수집을 위한 Log 시스템 개발 및 서버 연동.</li><li><b>데이터 보안:</b> 플레이어 저장 데이터 암호화 적용. ( XOR 암호화 )</li></ul></div><div><h4 class="font-semibold mb-1">밸런스 및 콘텐츠</h4><ul class="list-disc pl-5 space-y-1"><li><b>타워:</b> 궁수 타워 하향, 창 타워 상향, 타워형 스킬(`복수의 화신`, `기본타워 스킬`) 성능 개선</li><li><b>장비/특성:</b> 무기 고유 효과 재설정, 전체 장비의 공격 사거리 옵션 효율 50% 감소, `연쇄 폭발`, `약자 멸시` 특성 개선</li><li><b>적:</b> 난이도에 따라 적 스케일 및 종류가 다양해지도록 수정, 적 랜덤 방어력 생성 기능 추가</li><li><b>맵:</b> 신규 테마 맵 2종 추가 및 난이도별 맵 해금 기능 적용</li></ul></div><div><h4 class="font-semibold mb-1">기술적 개선 및 버그 수정 상세</h4><ul class="list-disc pl-5 space-y-3"><li><b><span class="text-red-600">■</span> 성능 최적화 (UI 전환):</b><p class="pl-4 text-xs">문제: 빌드 환경에서 UI 전환이 느려지는 문제 발생. → 해결: Time.timeScale에 영향받지 않도록 DeltaTime 기반으로 로직을 변경하고, animationDuration으로 속도를 제어.</p><div class="mt-3 space-y-4"><div class="bg-gray-900 text-gray-100 rounded-lg shadow"><button type="button" aria-expanded="false" class="flex w-full items-center justify-between px-4 py-3 text-left text-sm font-medium focus:outline-none focus-visible:ring-2 focus-visible:ring-indigo-500"><span>/UI/UIManager.cs - UI 전환 함수</span><span aria-hidden="true" class="transition-transform duration-200 ">▶</span></button></div></div></li><li><b>UI 대응성 개선:</b><p class="pl-4 text-xs">문제: 특정 해상도에서 버튼 UI가 크기에 맞지 않는 문제. → 해결: RectTransform의 앵커를 Stretch로 적용하여 해결.</p></li><li><b>UI 렌더링 오류:</b><p class="pl-4 text-xs">문제: 스킬 버튼 클릭 후 UI를 숨겼다 다시 표시하면 타워 아이콘이 올라오는 버그. → 해결: UIManager의 ShowUIAnimation 로직 수정으로 해결.</p></li><li><b>스킬 이펙트 잔상:</b><p class="pl-4 text-xs">문제: 게임 클리어 직전 `낙뢰` 스킬 사용 시 이펙트가 사라지지 않는 버그. → 해결: SkillThunder 스크립트에서 공격 시전 시 Null 체크를 추가하고, 이펙트를 비활성화가 아닌 즉시 Destroy 하도록 변경.</p></li><li><b>무한모드 로직 오류:</b><ul class="list-disc pl-6 space-y-1"><li>적이 남은 상태에서 보상 패널로 넘어가지 않고 즉시 다음 웨이브가 시작되는 버그 해결.<p class="pl-4 text-xs">- 체력 감소 로직 이후 보상 패널이 열리도록 순서 수정.</p></li><li>`타워 전문가` 특성 선택 시 타워 코스트 보상이 비정상적으로 적용되는 버그 해결.</li></ul></li></ul></div></div></div></div></div><div class="bg-white rounded-lg shadow p-6"><h2 class="text-2xl font-bold mb-4">통합 개발 일지 (Beta_v0.1.0)</h2><p class="text-sm mb-4">프로토타입에서 베타 버전으로 전환하며 적용된 주요 개발 내역입니다.</p><div class="space-y-6 text-sm"><div class="p-4 border-l-4 border-blue-500 bg-blue-50"><h3 class="font-semibold text-lg mb-2 text-blue-800">v0.1.0 (주요 시스템 및 콘텐츠 확장)</h3><div class="space-y-4"><div><h4 class="font-semibold mb-1">1. 대기실 및 난이도 시스템</h4><ul class="list-disc pl-5 space-y-1"><li>대기실에서 난이도 선택 및 장비 설정 가능</li><li>난이도별 적 체력/골드 배율 적용</li><li>ClearScene 및 클리어 점수/보상 연동</li></ul></div><div><h4 class="font-semibold mb-1">2. 장비 시스템</h4><ul class="list-disc pl-5 space-y-1"><li>로그라이크식 장비 획득/장착 시스템 완성</li><li>장비 정렬, 인벤토리 UI 및 장착/해제 기능 구현</li><li>장비 스탯 누적/중복 문제 수정</li></ul></div><div><h4 class="font-semibold mb-1">3. SpecialSkills 및 장비 특수 스킬</h4><ul class="list-disc pl-5 space-y-1"><li>장신구 장착 시 특수 스킬 활성화</li><li>Passive/Active/TowerInstall 3종 스킬 구조 구현</li><li>특수 스킬 발동 이벤트 처리 및 인게임 UI 연동</li></ul></div><div><h4 class="font-semibold mb-1">4. 웨이브 랜덤 보상</h4><ul class="list-disc pl-5 space-y-1"><li>웨이브 종료 시 보상 패널 선택 기능</li><li>골드 보상 스케일링 및 장비 드랍 추가</li><li>첫 웨이브: 10가지 특성 중 2개 제시 → 1개 선택 (게임 플레이 전반에 큰 영향)</li></ul></div><div><h4 class="font-semibold mb-1">5. 타워 아키타입/배치 로직 개선</h4><ul class="list-disc pl-5 space-y-1"><li>TowerArchetype 기반 동적 버튼/배치 시스템</li><li>하나의 TowerArchetype으로 한쌍의 타워데이터와 스킬데이터를 관리</li><li>타워 설치 안정화 및 널 참조 문제 해결</li><div class="mt-3 space-y-4"><div class="bg-gray-900 text-gray-100 rounded-lg shadow"><button type="button" aria-expanded="false" class="flex w-full items-center justify-between px-4 py-3 text-left text-sm font-medium focus:outline-none focus-visible:ring-2 focus-visible:ring-indigo-500"><span>/Data/Models/TowerArchetype.cs - 타워 &amp; 스킬 데이터 통합관리</span><span aria-hidden="true" class="transition-transform duration-200 ">▶</span></button></div></div></ul></div><div><h4 class="font-semibold mb-1">6. 툴팁 시스템</h4><ul class="list-disc pl-5 space-y-1"><li>장비, 타워, 스킬에 마우스 오버 시 툴팁 표시 (TooltipManager &amp; TooltipTrigger 활용)</li><div class="mt-3 space-y-4"><div class="bg-gray-900 text-gray-100 rounded-lg shadow"><button type="button" aria-expanded="false" class="flex w-full items-center justify-between px-4 py-3 text-left text-sm font-medium focus:outline-none focus-visible:ring-2 focus-visible:ring-indigo-500"><span>/System/TooltipManager.cs - 툴팁의 실질적인 표시를 담당</span><span aria-hidden="true" class="transition-transform duration-200 ">▶</span></button></div><div class="bg-gray-900 text-gray-100 rounded-lg shadow"><button type="button" aria-expanded="false" class="flex w-full items-center justify-between px-4 py-3 text-left text-sm font-medium focus:outline-none focus-visible:ring-2 focus-visible:ring-indigo-500"><span>/UI/TooltipTrigger.cs - 객체의 컴포넌트로 추가하여 툴팁 정보를 저장 및 이벤트 감지</span><span aria-hidden="true" class="transition-transform duration-200 ">▶</span></button></div></div></ul></div><div><h4 class="font-semibold mb-1">7. 알림 가시성 및 게임 속도 관리</h4><ul class="list-disc pl-5 space-y-1"><li>알림 겹침 문제 해결 및 중요도별 채널 분리</li><li>웨이브 대기 시간은 게임 속도와 독립</li></ul></div><div><h4 class="font-semibold mb-1">8. 맵/적/튜토리얼 추가</h4><ul class="list-disc pl-5 space-y-1"><li>신규 맵(눈 테마) 추가 및 맵 시드 기능 구현</li><li>적 스프라이트/애니메이션 추가 및 튜토리얼 텍스트 추가</li></ul></div><div><h4 class="font-semibold mb-1">9. 사운드 및 해상도/UI 개선</h4><ul class="list-disc pl-5 space-y-1"><li>사운드 볼륨 정규화</li><li>1280~1600 해상도 대응 UI 리팩토링</li></ul></div><div><h4 class="font-semibold mb-1">10. 기타 버그 수정</h4><ul class="list-disc pl-5 space-y-1"><li>타워 2D 콜라이더 크기 조정</li><li>장비 툴팁 표시 개선</li><li>웨이브 및 난이도 밸런스 계산식 수정</li></ul></div></div></div></div></div><div class="bg-white rounded-lg shadow p-6"><h2 class="text-2xl font-bold mb-4">통합 개발 일지 (Alpha_v0.3.0 이전)</h2><p class="text-sm mb-4">프로젝트 초기 프로토타이핑 단계의 주요 기술적 문제 해결 기록입니다.</p><div class="space-y-6 text-sm"><div class="p-4 border-l-4 border-gray-400"><h3 class="font-semibold text-lg mb-2">초기 프로토타입 기술적 문제 해결</h3><div class="space-y-4"><div><h4 class="font-semibold mb-1">핵심 로직 및 시스템 안정화</h4><ul class="list-disc pl-5 space-y-3"><li><b><span class="text-red-600">■</span> 몬스터 경로 이탈 문제 해결:</b><p class="pl-4 text-xs">문제: 프레임 드랍 발생 시, 다음 지점으로 방향 전환을 하지 못하고 맵 밖으로 직진함. → 해결: 목표 지점과의 거리와 방향을 매 프레임 계산하여, 목표 지점 이상으로 이동하지 않도록 로직 수정.</p><div class="mt-3 space-y-4"><div class="bg-gray-900 text-gray-100 rounded-lg shadow"><button type="button" aria-expanded="false" class="flex w-full items-center justify-between px-4 py-3 text-left text-sm font-medium focus:outline-none focus-visible:ring-2 focus-visible:ring-indigo-500"><span>/Enemy/Enemy.cs - 경로 탐색 및 이동</span><span aria-hidden="true" class="transition-transform duration-200 ">▶</span></button></div></div></li><li><b>적 추적 알고리즘 최적화:</b><p class="pl-4 text-xs">문제: 타워가 거리가 가깝다는 이유로 나중에 등장한 적을 먼저 공격함. → 해결: 공격 범위 내 적 탐지 시, 생성 순서가 빠른 적을 우선 공격하도록 탐색 로직 개선.</p></li><li><b>설치된 타워 선택 불가 오류 해결:</b><p class="pl-4 text-xs">문제: 타워 다수 설치 시 Z축 문제로 일부 타워가 선택되지 않음. → 해결: 타워 설치 시 Z축 값을 명시적으로 지정하여 렌더링 순서 보장.</p></li><li><b>타워 배치 UI 문제점 해결:</b><p class="pl-4 text-xs">문제: 타워 배치 UI 구현 시 타일맵 인식 문제 발생. → 해결: 타일맵에 Box Collider와 `Tile` 태그를 부여하여 마우스 클릭 위치의 타일을 정확하게 인식하도록 수정.</p></li><li><b>검사 타워 공격 시 에러 해결:</b><p class="pl-4 text-xs">문제: 검사 타워가 공격하는 순간 attackTarget이 null이 되어 `NullException` 발생. → 해결: 최종 AttackEnemy 함수 호출 직전에도 attackTarget의 null 상태를 한 번 더 확인하는 방어 코드를 추가하여 해결.</p></li><li><b>Hit 이펙트 관련 이슈 해결:</b><p class="pl-4 text-xs">문제: 공격 속도가 빠르면 이펙트가 정상 출력되지 않거나, 타워 판매 시 이펙트가 사라지지 않음. → 해결: 이펙트를 Instantiate로 복제하고 일정 시간 후 자동 Destroy 되도록 수정.</p></li><li><b>웨이브 랜덤 보상 이슈 해결:</b><p class="pl-4 text-xs">문제: SP가 최대치를 초과하거나, 랜덤 타워 보상이 이미 타워가 있는 곳에 겹쳐서 설치됨. → 해결: 조건문을 추가하여 최대치 초과를 방지하고, 타워 설치 전 타일이 비어있는지 확인하도록 개선.</p></li><li><b>UI 실시간 업데이트 문제 해결:</b><p class="pl-4 text-xs">문제: SP, Gold 등 재화 변경 시 UI가 즉시 갱신되지 않음. → 해결: 데이터 변경 시 이벤트를 발생시키는 프로퍼티(Property) 구조로 변경하고, UI가 이를 구독하여 즉시 반영하도록 수정.</p></li><li><b>타워 공격력 표기 문제 해결:</b><p class="pl-4 text-xs">문제: 버프 효과가 합산된 값으로만 표시되어 순수 공격력 파악 불가. → 해결: 기본, 업그레이드, 버프 공격력을 별도로 계산하고 UI에 구분하여 표시 (예: 10 + 2 + 3)하도록 개선.</p></li><li><b>스킬 효과 적용 오류:</b><p class="pl-4 text-xs">문제: 슬로우(Slow) 스킬 등이 적의 이동 속도를 제대로 제어하지 못하는 문제. → 해결: StatusEffect 스크립트가 Enemy 컴포넌트에 직접 접근하여 이동 속도를 제어하고, 효과 종료 시 원래 속도로 정확히 복원하도록 수정.</p></li></ul></div></div></div></div></div></div></div></div></div></div></section></main></main><footer class="py-6 pr-6 text-right text-sm text-gray-500">Copyright © 2025. WooGeun-Nam All rights reserved.</footer></section><script src="/towerdefense-portfolio/_next/static/chunks/webpack-5320886ccfd4601e.js" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0])</script><script>self.__next_f.push([1,"1:HL[\"/towerdefense-portfolio/_next/static/media/e4af272ccee01ff0-s.p.woff2\",\"font\",{\"crossOrigin\":\"\",\"type\":\"font/woff2\"}]\n2:HL[\"/towerdefense-portfolio/_next/static/css/9aecf071dd42db73.css\",\"style\"]\n0:\"$L3\"\n"])</script><script>self.__next_f.push([1,"4:HL[\"/towerdefense-portfolio/_next/static/css/986f079464c860c4.css\",\"style\"]\n"])</script><script>self.__next_f.push([1,"5:I{\"id\":6054,\"chunks\":[\"272:static/chunks/webpack-5320886ccfd4601e.js\",\"971:static/chunks/fd9d1056-d8f6cc25471773ac.js\",\"864:static/chunks/864-cda1ba0f2cbf2968.js\"],\"name\":\"\",\"async\":false}\n7:I{\"id\":1729,\"chunks\":[\"272:static/chunks/webpack-5320886ccfd4601e.js\",\"971:static/chunks/fd9d1056-d8f6cc25471773ac.js\",\"864:static/chunks/864-cda1ba0f2cbf2968.js\"],\"name\":\"\",\"async\":false}\n8:I{\"id\":4244,\"chunks\":[\"185:static/chunks/app/layout-9bda2e05cef98886.js\"],\"name\":\"\",\"async\":false}\n9:I{\"id\":7885,\"chunks\":[\"185:"])</script><script>self.__next_f.push([1,"static/chunks/app/layout-9bda2e05cef98886.js\"],\"name\":\"\",\"async\":false}\na:I{\"id\":1443,\"chunks\":[\"272:static/chunks/webpack-5320886ccfd4601e.js\",\"971:static/chunks/fd9d1056-d8f6cc25471773ac.js\",\"864:static/chunks/864-cda1ba0f2cbf2968.js\"],\"name\":\"\",\"async\":false}\nb:I{\"id\":8639,\"chunks\":[\"272:static/chunks/webpack-5320886ccfd4601e.js\",\"971:static/chunks/fd9d1056-d8f6cc25471773ac.js\",\"864:static/chunks/864-cda1ba0f2cbf2968.js\"],\"name\":\"\",\"async\":false}\nc:I{\"id\":3891,\"chunks\":[\"616:static/chunks/616-e434e4cfad8"])</script><script>self.__next_f.push([1,"6db7c.js\",\"570:static/chunks/app/projects/layout-7c01550692a51787.js\"],\"name\":\"\",\"async\":false}\n"])</script><script>self.__next_f.push([1,"3:[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/towerdefense-portfolio/_next/static/css/9aecf071dd42db73.css\",\"precedence\":\"next\"}]],[\"$\",\"$L5\",null,{\"buildId\":\"mLV-WzYrkhgKp75GMUyml\",\"assetPrefix\":\"/towerdefense-portfolio\",\"initialCanonicalUrl\":\"/projects/roguetower/\",\"initialTree\":[\"\",{\"children\":[\"projects\",{\"children\":[\"roguetower\",{\"children\":[\"__PAGE__\",{}]}]}]},\"$undefined\",\"$undefined\",true],\"initialHead\":[false,\"$L6\"],\"globalErrorComponent\":\"$7\",\"children\":[null,[\"$\",\"html\",null,{\"lang\":\"ko\",\"className\":\"scroll-smooth\",\"suppressHydrationWarning\":true,\"children\":[[\"$\",\"$L8\",null,{\"src\":\"https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js\",\"strategy\":\"afterInteractive\"}],[\"$\",\"$L8\",null,{\"src\":\"https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-csharp.min.js\",\"strategy\":\"afterInteractive\"}],[\"$\",\"$L8\",null,{\"src\":\"https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js\",\"strategy\":\"afterInteractive\"}],[\"$\",\"head\",null,{\"children\":[[\"$\",\"link\",null,{\"rel\":\"stylesheet\",\"href\":\"https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css\"}],[\"$\",\"link\",null,{\"rel\":\"stylesheet\",\"href\":\"https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.css\"}]]}],[\"$\",\"body\",null,{\"className\":\"__className_94e1b1 min-h-dvh bg-gray-100 antialiased\",\"children\":[[\"$\",\"$L9\",null,{}],[\"$\",\"$La\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\"],\"loading\":\"$undefined\",\"loadingStyles\":\"$undefined\",\"hasLoading\":false,\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"template\":[\"$\",\"$Lb\",null,{}],\"templateStyles\":\"$undefined\",\"notFound\":[[\"$\",\"title\",null,{\"children\":\"404: This page could not be found.\"}],[\"$\",\"div\",null,{\"style\":{\"fontFamily\":\"system-ui,\\\"Segoe UI\\\",Roboto,Helvetica,Arial,sans-serif,\\\"Apple Color Emoji\\\",\\\"Segoe UI Emoji\\\"\",\"height\":\"100vh\",\"textAlign\":\"center\",\"display\":\"flex\",\"flexDirection\":\"column\",\"alignItems\":\"center\",\"justifyContent\":\"center\"},\"children\":[\"$\",\"div\",null,{\"children\":[[\"$\",\"style\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}\"}}],[\"$\",\"h1\",null,{\"className\":\"next-error-h1\",\"style\":{\"display\":\"inline-block\",\"margin\":\"0 20px 0 0\",\"padding\":\"0 23px 0 0\",\"fontSize\":24,\"fontWeight\":500,\"verticalAlign\":\"top\",\"lineHeight\":\"49px\"},\"children\":\"404\"}],[\"$\",\"div\",null,{\"style\":{\"display\":\"inline-block\"},\"children\":[\"$\",\"h2\",null,{\"style\":{\"fontSize\":14,\"fontWeight\":400,\"lineHeight\":\"49px\",\"margin\":0},\"children\":\"This page could not be found.\"}]}]]}]}]],\"notFoundStyles\":[],\"childProp\":{\"current\":[null,[\"$\",\"section\",null,{\"children\":[[\"$\",\"$Lc\",null,{}],[\"$\",\"main\",null,{\"className\":\"mx-auto w-full max-w-6xl pt-16\",\"children\":[\"$\",\"$La\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"projects\",\"children\"],\"loading\":\"$undefined\",\"loadingStyles\":\"$undefined\",\"hasLoading\":false,\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"template\":[\"$\",\"$Lb\",null,{}],\"templateStyles\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\",\"childProp\":{\"current\":[\"$\",\"$La\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"projects\",\"children\",\"roguetower\",\"children\"],\"loading\":\"$undefined\",\"loadingStyles\":\"$undefined\",\"hasLoading\":false,\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"template\":[\"$\",\"$Lb\",null,{}],\"templateStyles\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\",\"childProp\":{\"current\":[\"$Ld\",\"$Le\",null],\"segment\":\"__PAGE__\"},\"styles\":[]}],\"segment\":\"roguetower\"},\"styles\":[]}]}],[\"$\",\"footer\",null,{\"className\":\"py-6 pr-6 text-right text-sm text-gray-500\",\"children\":\"Copyright © 2025. WooGeun-Nam All rights reserved.\"}]]}],null],\"segment\":\"projects\"},\"styles\":[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/towerdefense-portfolio/_next/static/css/986f079464c860c4.css\",\"precedence\":\"next\"}]]}]]}]]}],null]}]]\n"])</script><script>self.__next_f.push([1,"6:[[\"$\",\"meta\",\"0\",{\"charSet\":\"utf-8\"}],[\"$\",\"title\",\"1\",{\"children\":\"WooGeun Nam\"}],[\"$\",\"meta\",\"2\",{\"name\":\"description\",\"content\":\"웹 포트폴리오\"}],[\"$\",\"meta\",\"3\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}],[\"$\",\"link\",\"4\",{\"rel\":\"icon\",\"href\":\"./../Logo.ico\"}],[\"$\",\"meta\",\"5\",{\"name\":\"next-size-adjust\"}]]\nd:null\n"])</script><script>self.__next_f.push([1,"f:I{\"id\":2148,\"chunks\":[\"899:static/chunks/app/projects/roguetower/page-e55c39eecd1147f4.js\"],\"name\":\"\",\"async\":false}\n10:I{\"id\":8016,\"chunks\":[\"899:static/chunks/app/projects/roguetower/page-e55c39eecd1147f4.js\"],\"name\":\"\",\"async\":false}\n11:T34c3,"])</script><script>self.__next_f.push([1,"using UnityEngine;\nusing UnityEngine.Audio;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Collections;\n\npublic class SoundManager : MonoBehaviour\n{\n    public static SoundManager Instance { get; private set; }\n\n    public AudioMixer masterMixer;\n\n    private AudioSource bgmPlayer;\n    private List\u003cAudioSource\u003e sfxSources = new List\u003cAudioSource\u003e();\n    private Dictionary\u003cGameObject, AudioSource\u003e loopingSfxSources = new Dictionary\u003cGameObject, AudioSource\u003e();\n    [Tooltip(\"동시에 재생할 수 있는 최대 효과음 개수\")]\n    [SerializeField] private int maxSfxSources = 20; // 인스펙터에서 조절 가능\n    \n    // 사운드 쿨다운(재생 조절)을 위한 변수들\n    [Tooltip(\"동일한 사운드를 다시 재생하기까지 필요한 최소 시간 간격 (초)\")]\n    [SerializeField] private float sfxThrottleTime = 0.05f;\n    private Dictionary\u003cstring, float\u003e _sfxCooldowns = new Dictionary\u003cstring, float\u003e();\n\n    private string currentBgmName; // BGM이 바뀔 때마다 이 변수에 이름을 저장\n    \n    // 오디오 클립 및 분석 데이터를 관리할 Dictionary\n    private Dictionary\u003cstring, AudioClip[]\u003e audioClips;\n    private Dictionary\u003cstring, float\u003e clipPeakVolumes = new Dictionary\u003cstring, float\u003e(); // 오디오 클립의 피크 볼륨을 캐싱\n\n    private const float TARGET_PEAK_VOLUME = 0.7f; // 볼륨 정규화를 위한 목표 피크 값 (오디오 클리핑 방지를 위해 1.0f 보다 낮게 설정)\n\n    // === 추가된 상수 정의 ===\n    private const string GAME_BGM_PREFIX = \"BGM_Game_\"; // 인게임 BGM 파일을 식별하기 위한 접두사\n    private const string TUTORIAL_BGM_NAME = \"BGM_Game_1\"; // 튜토리얼에서 사용할 BGM 이름\n    \n    // 초기화 상태를 외부에 알릴 수 있는 변수\n    public bool IsInitialized { get; private set; } = false;\n    \n    public float InitializationProgress { get; private set; } = 0f; // [추가] 초기화 진행률\n    \n    private void Awake()\n    {\n        if (Instance == null)\n        {\n            Instance = this;\n            DontDestroyOnLoad(gameObject);\n\n            bgmPlayer = gameObject.AddComponent\u003cAudioSource\u003e();\n            bgmPlayer.outputAudioMixerGroup = masterMixer.FindMatchingGroups(\"BGM\")[0];\n            \n            for (int i = 0; i \u003c maxSfxSources; i++)\n            {\n                AudioSource sfxSource = gameObject.AddComponent\u003cAudioSource\u003e();\n                sfxSource.outputAudioMixerGroup = masterMixer.FindMatchingGroups(\"SFX\")[0];\n                sfxSource.loop = false;\n                sfxSources.Add(sfxSource);\n            }\n            \n            IsInitialized = false;\n            StartCoroutine(LoadAndAnalyzeAudioClipsAsync());\n        }\n        else\n        {\n            Destroy(gameObject);\n        }\n    }\n\n    // === 볼륨 정규화 기능이 적용된 재생 함수 ===\n\n    // 동일한 BGM이 이미 재생 중일 경우 다시 시작하지 않도록 수정\n    public void PlayBGM(string clipName, bool loop = true, float volume = 1.0f, float pitch = 1.0f)\n    {\n        AudioClip clip = FindClip(clipName);\n        if (clip == null) return;\n\n        // 현재 재생 중인 클립이 요청된 클립과 동일하면 아무것도 하지 않고 리턴\n        if (bgmPlayer.isPlaying \u0026\u0026 bgmPlayer.clip != null \u0026\u0026 bgmPlayer.clip.name == clip.name)\n        {\n            return;\n        }\n\n        bgmPlayer.clip = clip;\n        bgmPlayer.loop = loop;\n        bgmPlayer.volume = GetAdjustedVolume(clipName, volume);\n        bgmPlayer.pitch = pitch;\n        bgmPlayer.Play();\n        \n        currentBgmName = clipName; // BGM 이름 저장\n    }\n    \n    // AnalyticsDebugUI에서 호출할 getter 메소드\n    public string GetCurrentBGMName()\n    {\n        if (bgmPlayer != null \u0026\u0026 bgmPlayer.isPlaying)\n        {\n            return currentBgmName;\n        }\n        return \"Not Playing\";\n    }\n\n    //  게임 BGM 랜덤 재생 메서드\n    public void PlayRandomGameBGM()\n    {\n        // 튜토리얼 완료 여부 확인\n        if (PlayerPrefs.GetInt(\"TutorialCompleted\", 0) == 0)\n        {\n            // 튜토리얼 중일 경우, 지정된 튜토리얼 BGM 재생\n            PlayBGM(TUTORIAL_BGM_NAME, true);\n        }\n        else\n        {\n            // 튜토리얼 완료 시, 랜덤 BGM 재생\n            if (audioClips.TryGetValue(\"BGM\", out AudioClip[] bgmClips))\n            {\n                // \"BGM_Game_\" 접두사를 가진 모든 BGM 클립을 리스트로 가져옴\n                List\u003cAudioClip\u003e gameBgmList = bgmClips.Where(clip =\u003e clip.name.StartsWith(GAME_BGM_PREFIX)).ToList();\n\n                if (gameBgmList.Count \u003e 0)\n                {\n                    // 리스트에서 랜덤하게 BGM 하나를 선택\n                    AudioClip randomClip = gameBgmList[Random.Range(0, gameBgmList.Count)];\n                    PlayBGM(randomClip.name, true);\n                }\n                else\n                {\n                    Debug.LogWarning($\"'{GAME_BGM_PREFIX}' 접두사를 가진 게임 BGM을 찾을 수 없습니다.\");\n                }\n            }\n        }\n    }\n    \n    public void PlaySFX(string clipName, float volume = 1.0f, float pitch = 1.0f)\n    {\n        AudioClip clip = FindClip(clipName);\n        if (clip == null) return;\n        \n        // 이전에 이 사운드를 재생한 기록이 있는지 확인합니다.\n        if (_sfxCooldowns.ContainsKey(clipName))\n        {\n            // 마지막 재생 시간과 현재 시간을 비교하여, 설정된 쿨다운 시간(sfxThrottleTime)이 지나지 않았다면\n            // 소리를 재생하지 않고 즉시 함수를 종료합니다.\n            if (Time.unscaledTime - _sfxCooldowns[clipName] \u003c sfxThrottleTime)\n            {\n                return;\n            }\n        }\n\n        // 오디오 소스 풀에서 비어있는 소스를 찾아옵니다.\n        AudioSource sourceToPlay = GetAvailableSfxSource();\n        if (sourceToPlay == null) return;\n        \n        // 재생 직전에, 현재 시간을 마지막 재생 시간으로 기록(갱신)합니다.\n        _sfxCooldowns[clipName] = Time.unscaledTime;\n\n        // 찾은 소스를 사용하여 효과음을 재생합니다.\n        sourceToPlay.pitch = pitch;\n        sourceToPlay.PlayOneShot(clip, GetAdjustedVolume(clipName, volume));\n    }\n\n    public void PlayLoopingSFX(string clipName, GameObject caller, float volume = 1.0f, float pitch = 1.0f)\n    {\n        if (loopingSfxSources.ContainsKey(caller))\n        {\n            // 이미 재생 중인 경우, 볼륨과 피치만 업데이트\n            loopingSfxSources[caller].volume = GetAdjustedVolume(clipName, volume); // 볼륨 업데이트 시에도 정규화 적용\n            loopingSfxSources[caller].pitch = pitch;\n            return;\n        }\n\n        AudioClip clip = FindClip(clipName);\n        if (clip != null)\n        {\n            GameObject obj = new GameObject($\"LoopingSFX_{clipName}_{caller.name}\");\n            obj.transform.SetParent(transform);\n            AudioSource source = obj.AddComponent\u003cAudioSource\u003e();\n            source.outputAudioMixerGroup = masterMixer.FindMatchingGroups(\"SFX\")[0];\n            source.clip = clip;\n            source.loop = true;\n            source.volume = GetAdjustedVolume(clipName, volume); // 정규화된 볼륨 적용\n            source.pitch = pitch;\n            source.Play();\n            loopingSfxSources.Add(caller, source);\n        }\n    }\n\n    // === 오디오 클립 로드 및 분석 로직 ===\n    \n    // [수정] 동기 함수를 비동기 코루틴으로 변경\n    private IEnumerator LoadAndAnalyzeAudioClipsAsync()\n    {\n        audioClips = new Dictionary\u003cstring, AudioClip[]\u003e();\n        clipPeakVolumes = new Dictionary\u003cstring, float\u003e();\n\n        // 지정된 모든 경로의 오디오 클립을 비동기로 로드하고 분석\n        yield return StartCoroutine(LoadClipsFromPathAsync(\"BGM\"));\n        yield return StartCoroutine(LoadClipsFromPathAsync(\"Tower\"));\n        yield return StartCoroutine(LoadClipsFromPathAsync(\"Enemy\"));\n        yield return StartCoroutine(LoadClipsFromPathAsync(\"Skill\"));\n        yield return StartCoroutine(LoadClipsFromPathAsync(\"UI\"));\n        yield return StartCoroutine(LoadClipsFromPathAsync(\"System\"));\n        IsInitialized = true; // 모든 로딩이 완료되었음을 알립니다.\n    }\n\n    // [수정] 경로에서 오디오 클립을 비동기로 로드하는 코루틴\n    private IEnumerator LoadClipsFromPathAsync(string path)\n    {\n        // 1. 먼저 경로에 있는 모든 클립의 참조를 동기적으로 가져옵니다. (이 과정은 매우 빠름)\n        AudioClip[] clips = Resources.LoadAll\u003cAudioClip\u003e(\"Sound/\" + path);\n\n        if (clips.Length \u003e 0)\n        {\n            // 2. 클립 배열을 저장\n            audioClips.Add(path, clips);\n        \n            // 3. 각 클립에 대해 비동기 로딩 및 분석을 진행합니다.\n            foreach (AudioClip clip in clips)\n            {\n                if (!clipPeakVolumes.ContainsKey(clip.name))\n                {\n                    string fullPath = \"Sound/\" + path + \"/\" + clip.name;\n\n                    ResourceRequest request = Resources.LoadAsync\u003cAudioClip\u003e(fullPath);\n                \n                    // 로딩이 완료될 때까지 기다립니다.\n                    while (!request.isDone)\n                    {\n                        yield return null;\n                    }\n                    // 로딩이 완료된 클립을 분석합니다.\n                    float peakVolume = AnalyzeClipPeakVolume((AudioClip)request.asset);\n                    clipPeakVolumes.Add(clip.name, peakVolume);\n                }\n            }\n        }\n    }\n\n    private float AnalyzeClipPeakVolume(AudioClip clip)\n    {\n        // 클립의 모든 오디오 샘플 데이터를 가져옴\n        float[] samples = new float[clip.samples * clip.channels];\n        clip.GetData(samples, 0);\n\n        float peakVolume = 0f;\n        for (int i = 0; i \u003c samples.Length; i++)\n        {\n            // 샘플의 절대값이 현재 피크 값보다 크면 업데이트\n            float currentSample = Mathf.Abs(samples[i]);\n            if (currentSample \u003e peakVolume)\n            {\n                peakVolume = currentSample;\n            }\n        }\n        return peakVolume;\n    }\n\n    private float GetAdjustedVolume(string clipName, float originalVolume)\n    {\n        if (clipPeakVolumes.TryGetValue(clipName, out float peakVolume))\n        {\n            // 피크 볼륨이 매우 작으면(거의 무음이면) 과도하게 증폭되는 것을 방지\n            if (peakVolume \u003c 0.01f)\n            {\n                return originalVolume;\n            }\n            // 목표 피크 볼륨을 기준으로 정규화된 볼륨 계산\n            return originalVolume * (TARGET_PEAK_VOLUME / peakVolume);\n        }\n        return originalVolume; // 분석 데이터가 없는 경우 원래 볼륨 사용\n    }\n\n    // === 기존 유틸리티 함수들 (변경 없음) ===\n\n    public void StopLoopingSFX(GameObject caller)\n    {\n        if (loopingSfxSources.ContainsKey(caller))\n        {\n            AudioSource source = loopingSfxSources[caller];\n            if (source != null)\n            {\n                source.Stop();\n                Destroy(source.gameObject);\n            }\n            loopingSfxSources.Remove(caller);\n        }\n    }\n\n    public void StopAllLoopingSFX()\n    {\n        foreach (var entry in loopingSfxSources)\n        {\n            entry.Value.Stop();\n            Destroy(entry.Value.gameObject);\n        }\n        loopingSfxSources.Clear();\n    }\n\n    public void SetBGMVolume(float volume)\n    {\n        float dB = ConvertVolumeToDb(volume);\n        masterMixer.SetFloat(\"BGMVolume\", dB);\n    }\n\n    public void SetSFXVolume(float volume)\n    {\n        float dB = ConvertVolumeToDb(volume);\n        masterMixer.SetFloat(\"SFXVolume\", dB);\n    }\n\n    public void SetMasterVolume(float volume)\n    {\n        float dB = ConvertVolumeToDb(volume);\n        masterMixer.SetFloat(\"MasterVolume\", dB);\n    }\n\n    private float ConvertVolumeToDb(float volume)\n    {\n        return volume \u003e 0.0001f ? Mathf.Log10(volume) * 20 : -80f;\n    }\n\n    public void StopAllSounds()\n    {\n        bgmPlayer.Stop();\n        \n        // sfxPlayer.Stop(); // 기존 코드 삭제\n        foreach (var source in sfxSources)\n        {\n            source.Stop();\n        }\n\n        StopAllLoopingSFX();\n    }\n\n    public AudioClip FindClip(string clipName)\n    {\n        foreach (var key in audioClips.Keys)\n        {\n            foreach (var clip in audioClips[key])\n            {\n                if (clip.name.Equals(clipName))\n                {\n                    return clip;\n                }\n            }\n        }\n        Debug.LogWarning($\"AudioClip not found: {clipName}\"); // 클립을 찾지 못했을 때 경고 메시지 추가\n        return null;\n    }\n    \n    private AudioSource GetAvailableSfxSource()\n    {\n        // sfxSources 리스트를 처음부터 순회합니다.\n        foreach (var source in sfxSources)\n        {\n            // 현재 재생 중이 아닌 소스를 찾으면, 그 소스를 즉시 반환합니다.\n            if (!source.isPlaying)\n            {\n                return source;\n            }\n        }\n        \n        // 모든 소스가 사용 중이라면(위의 반복문에서 반환되지 않았다면), null을 반환합니다.\n        return null;\n    }\n}"])</script><script>self.__next_f.push([1,"12:Te7c,"])</script><script>self.__next_f.push([1,"using UnityEngine;\nusing PlayFab;\nusing PlayFab.ClientModels;\nusing System.Collections.Generic;\n\n/// \u003csummary\u003e\n/// 게임 중 발생하는 치명적인 예외(Exception)를 감지하여 PlayFab으로 전송하는 클래스.\n/// 이 스크립트를 가진 빈 게임 오브젝트를 만들어 첫 씬에 배치하세요.\n/// \u003c/summary\u003e\npublic class ExceptionReporter : MonoBehaviour\n{\n    public static ExceptionReporter Instance { get; private set; }\n    \n    // 한 세션에서 동일한 오류가 반복적으로 전송되는 것을 막기 위한 Set\n    private HashSet\u003cstring\u003e _sentExceptionsThisSession = new HashSet\u003cstring\u003e();\n\n    private void Awake()\n    {\n        if (Instance == null)\n        {\n            Instance = this;\n            DontDestroyOnLoad(gameObject);\n        }\n        else\n        {\n            Destroy(gameObject);\n        }\n    }\n\n    private void OnEnable()\n    {\n        // Unity의 로그 메시지 이벤트를 구독합니다.\n        Application.logMessageReceived += HandleLog;\n    }\n\n    private void OnDisable()\n    {\n        // 구독을 해제합니다.\n        Application.logMessageReceived -= HandleLog;\n    }\n\n    /// \u003csummary\u003e\n    /// Unity의 모든 로그 메시지가 호출될 때 실행되는 핸들러 메서드입니다.\n    /// \u003c/summary\u003e\n    /// \u003cparam name=\"logString\"\u003e오류 메시지\u003c/param\u003e\n    /// \u003cparam name=\"stackTrace\"\u003e호출 스택\u003c/param\u003e\n    /// \u003cparam name=\"type\"\u003e로그 타입 (Log, Warning, Error, Exception 등)\u003c/param\u003e\n    private void HandleLog(string logString, string stackTrace, LogType type)\n    {\n        // 로그 타입이 Exception일 경우에만 처리합니다.\n        // (Warning이나 Error까지 보내면 너무 많은 데이터가 쌓일 수 있습니다.)\n        if (type == LogType.Exception)\n        {\n            // 이 세션에서 이미 보낸적 있는 오류 메시지라면 건너뜁니다. (서버 과부하 방지)\n            if (_sentExceptionsThisSession.Contains(logString))\n            {\n                return;\n            }\n            \n            // PlayFab 클라이언트가 로그인 상태인지 확인합니다.\n            if (!PlayFabClientAPI.IsClientLoggedIn())\n            {\n                return;\n            }\n            \n            // 전송할 데이터를 구성합니다.\n            var request = new WriteClientPlayerEventRequest\n            {\n                EventName = \"client_exception\", // 이벤트 이름\n                Body = new Dictionary\u003cstring, object\u003e\n                {\n                    { \"error_message\", logString }, // 실제 오류 메시지\n                    { \"stack_trace\", stackTrace },   // 호출 스택 (가장 중요!)\n                    { \"game_version\", Application.version }, // 게임 버전\n                    { \"scene_name\", UnityEngine.SceneManagement.SceneManager.GetActiveScene().name } // 오류 발생 씬\n                    // 필요하다면 다른 유용한 정보 (예: 플레이어 레벨, 현재 웨이브 등)를 추가할 수 있습니다.\n                }\n            };\n            \n            // PlayFab으로 이벤트 전송\n            PlayFabClientAPI.WritePlayerEvent(request, \n                result =\u003e {\n                    Debug.Log(\"\u003ccolor=orange\u003e[ExceptionReporter] 치명적 오류 정보를 PlayFab으로 전송했습니다.\u003c/color\u003e\");\n                },\n                error =\u003e {\n                    Debug.LogError(\"[ExceptionReporter] 오류 정보 전송 실패: \" + error.GenerateErrorReport());\n                }\n            );\n            \n            // 보낸 오류 목록에 추가하여 중복 전송을 방지합니다.\n            _sentExceptionsThisSession.Add(logString);\n        }\n    }\n}"])</script><script>self.__next_f.push([1,"13:Te78,"])</script><script>self.__next_f.push([1,"using System.Collections;\nusing UnityEngine;\nusing UnityEngine.UI;\nusing UnityEngine.SceneManagement;\nusing TMPro;\n\n/// \u003csummary\u003e\n/// 로딩 씬을 관리하고 비동기적으로 씬을 로드하는 클래스\n/// \u003c/summary\u003e\npublic class LoadingSceneController : MonoBehaviour\n{\n    private static string nextScene; // 다음으로 로드할 씬의 이름\n\n    [Tooltip(\"로딩 진행률을 표시하는 슬라이더 UI\")]\n    public Slider progressBar;\n    [Tooltip(\"로딩 상태 텍스트를 표시하는 UI\")]\n    public TextMeshProUGUI loadText;\n    \n    private void Start()\n    {\n        // ProgressBar의 값을 항상 0으로 초기화합니다.\n        progressBar.value = 0f;\n        \n        // 모든 사운드 중지\n        if (SoundManager.Instance != null)\n        {\n            SoundManager.Instance.StopAllSounds();\n        }\n\n        StartCoroutine(LoadSceneWithCleanup());\n    }\n\n    /// \u003csummary\u003e\n    /// 지정된 씬으로 로딩 씬을 통해 전환합니다.\n    /// \u003c/summary\u003e\n    /// \u003cparam name=\"sceneName\"\u003e로드할 씬의 이름\u003c/param\u003e\n    public static void LoadScene(string sceneName)\n    {\n        nextScene = sceneName;\n        SceneManager.LoadScene(\"LoadingScene\");\n    }\n\n    /// \u003csummary\u003e\n    /// [수정] 리소스 정리와 씬 로딩을 함께 처리하는 최종 코루틴입니다.\n    /// \u003c/summary\u003e\n    private IEnumerator LoadSceneWithCleanup()\n    {\n        yield return null; // 한 프레임 대기하여 UI가 제대로 표시될 시간을 줌\n\n        // --- 1단계: 리소스 정리 (프로그레스 바 0% -\u003e 50%) ---\n        if (loadText != null) loadText.text = \"Cleaning up resources...\";\n        \n        // 사용되지 않는 에셋을 메모리에서 강제로 해제합니다.\n        AsyncOperation unloadOperation = Resources.UnloadUnusedAssets();\n        while (!unloadOperation.isDone)\n        {\n            // 정리 과정 동안 프로그레스 바를 0%에서 50%까지 채웁니다.\n            if (progressBar != null) progressBar.value = unloadOperation.progress * 0.5f;\n            if (loadText != null) loadText.text = $\"Cleaning up... {progressBar.value * 100:F0}%\";\n            yield return null;\n        }\n\n        // 가비지 컬렉터를 수동으로 호출하여 메모리를 정리합니다.\n        System.GC.Collect();\n        // Debug.Log(\"리소스 정리 및 가비지 컬렉션 완료.\");\n\n        // --- 2단계: 다음 씬 비동기 로드 (프로그레스 바 50% -\u003e 100%) ---\n        if (loadText != null) loadText.text = \"Loading scene...\";\n        \n        AsyncOperation operation = SceneManager.LoadSceneAsync(nextScene);\n        operation.allowSceneActivation = false;\n\n        float timer = 0f;\n        while (!operation.isDone)\n        {\n            yield return null;\n\n            if (operation.progress \u003c 0.9f)\n            {\n                // 씬 로딩 과정을 프로그레스 바의 50%에서 95%까지 채웁니다. (0.5f + progress * 0.45f)\n                progressBar.value = 0.5f + (operation.progress * 0.45f);\n                if (loadText != null) loadText.text = $\"Loading... {progressBar.value * 100:F0}%\";\n            }\n            else\n            {\n                // 씬 로딩이 거의 끝나면 95%에서 100%까지 부드럽게 채웁니다.\n                timer += Time.unscaledDeltaTime;\n                progressBar.value = Mathf.Lerp(0.95f, 1f, timer);\n                if (loadText != null) loadText.text = $\"Loading... {progressBar.value * 100:F0}%\";\n\n                if (progressBar.value \u003e= 1f)\n                {\n                    operation.allowSceneActivation = true; // 씬 활성화\n                    yield break;\n                }\n            }\n        }\n    }\n}\n"])</script><script>self.__next_f.push([1,"14:T1feb,"])</script><script>self.__next_f.push([1,"using UnityEngine;\nusing TMPro;\nusing UnityEngine.UI;\nusing System.Collections;\nusing System.Collections.Generic;\n\npublic enum GachaType\n{\n    Normal,\n    Advanced,\n    Rare\n}\n\npublic class ShopManager : MonoBehaviour\n{\n    public static ShopManager Instance { get; private set; }\n\n    [Header(\"Gacha Settings\")]\n    [Tooltip(\"일반 뽑기 비용\")]\n    [SerializeField] private int normalGachaCost = 50000;\n    [Tooltip(\"고급 뽑기 비용\")]\n    [SerializeField] private int advancedGachaCost = 100000;\n    [Tooltip(\"희귀 뽑기 비용\")]\n    [SerializeField] private int rareGachaCost = 200000;\n    [SerializeField] private float gachaAnimationDuration = 2f;\n\n    [Header(\"UI References\")]\n    [SerializeField] private TextMeshProUGUI rCoinText;\n    [SerializeField] private Button normalDrawButton;\n    [SerializeField] private Button advancedDrawButton;\n    [SerializeField] private Button rareDrawButton;\n    \n    [Header(\"Animation Panel\")]\n    [SerializeField] private GameObject gachaAnimationPanel;\n    [SerializeField] private Image rewardImage;\n    [SerializeField] private TextMeshProUGUI rewardNameText;\n    [SerializeField] private TextMeshProUGUI rewardDescriptionText;\n    [SerializeField] private Slider gachaSlider;\n    [SerializeField] private GameObject gachaCloseButton; // [추가] 닫기 버튼의 GameObject를 연결할 변수\n\n    private bool isGachaInProgress = false;\n\n    private void Awake()\n    {\n        if (Instance == null) Instance = this;\n        else Destroy(gameObject);\n    }\n\n    private void OnEnable()\n    {\n        UpdateRCoinDisplay();\n        if (gachaAnimationPanel != null)\n        {\n            gachaAnimationPanel.SetActive(false);\n        }\n    }\n\n    public void UpdateRCoinDisplay()\n    {\n        if (EquipmentManager.Instance != null \u0026\u0026 EquipmentManager.Instance.currentPlayerData != null)\n        {\n            int currentRCoin = EquipmentManager.Instance.currentPlayerData.rCoin;\n            rCoinText.text = currentRCoin.ToString(\"N0\");\n            \n            if (!isGachaInProgress)\n            {\n                normalDrawButton.interactable = currentRCoin \u003e= normalGachaCost;\n                advancedDrawButton.interactable = currentRCoin \u003e= advancedGachaCost;\n                rareDrawButton.interactable = currentRCoin \u003e= rareGachaCost;\n            }\n        }\n    }\n\n    public void OnClickDraw(int gachaTypeIndex)\n    {\n        if (isGachaInProgress) return;\n\n        // 숫자로 받은 타입을 Enum으로 변환\n        GachaType type = (GachaType)gachaTypeIndex;\n        int cost = 0;\n\n        // 타입에 맞는 비용 설정\n        switch (type)\n        {\n            case GachaType.Normal:\n                cost = normalGachaCost;\n                break;\n            case GachaType.Advanced:\n                cost = advancedGachaCost;\n                break;\n            case GachaType.Rare:\n                cost = rareGachaCost;\n                break;\n        }\n\n        // 재화 확인 및 차감\n        PlayerData playerData = EquipmentManager.Instance.currentPlayerData;\n        if (playerData.rCoin \u003c cost)\n        {\n            // Debug.Log(\"RCoin이 부족합니다.\");\n            return;\n        }\n        \n        SoundManager.Instance.PlaySFX(\"SFX_UI_UseCoin\");\n        \n        playerData.rCoin -= cost;\n        GameDataManager.Instance.SavePlayerData(playerData);\n        UpdateRCoinDisplay();\n        \n        // 애니메이션 코루틴 시작\n        StartCoroutine(StartGachaAnimation(type));\n    }\n\n    private IEnumerator StartGachaAnimation(GachaType type)\n    {\n        isGachaInProgress = true;\n        normalDrawButton.interactable = false;\n        advancedDrawButton.interactable = false;\n        rareDrawButton.interactable = false;\n\n        try\n        {\n            gachaAnimationPanel.SetActive(true);\n            SoundManager.Instance.PlaySFX(\"SFX_UI_Gacha\");\n            \n            gachaSlider.value = 0;\n            if (rewardDescriptionText != null) rewardDescriptionText.text = \"\";\n            if (gachaCloseButton != null) gachaCloseButton.SetActive(false);\n            \n            EquipmentDataModel finalRewardData = LootManager.Instance.GetRandomEquipmentFromGacha(type);\n            if (finalRewardData == null)\n            {\n                Debug.LogError(\"가챠에서 장비를 뽑지 못했습니다. LootManager를 확인하세요.\");\n                yield break;\n            }\n\n            // 아이콘 프리로딩 시작\n            List\u003cSprite\u003e droppableSprites = new List\u003cSprite\u003e();\n            List\u003cEquipmentDataModel\u003e allEquipment = LootManager.Instance.AllDroppableEquipment;\n            \n            if (allEquipment != null)\n            {\n                foreach (var item in allEquipment)\n                {\n                    Sprite loadedSprite = Resources.Load\u003cSprite\u003e(item.iconPath);\n                    if (loadedSprite != null) droppableSprites.Add(loadedSprite);\n                }\n            }\n            \n            float elapsedTime = 0f;\n            float slotChangeTimer = 0f;\n            while (elapsedTime \u003c gachaAnimationDuration)\n            {\n                elapsedTime += Time.deltaTime;\n                gachaSlider.value = elapsedTime / gachaAnimationDuration;\n                slotChangeTimer -= Time.deltaTime;\n                if (slotChangeTimer \u003c= 0f)\n                {\n                    slotChangeTimer = Random.Range(0.02f, 0.1f);\n                    if (droppableSprites.Count \u003e 0)\n                    {\n                        rewardImage.sprite = droppableSprites[Random.Range(0, droppableSprites.Count)];\n                        EquipmentDataModel randomItem = allEquipment[Random.Range(0, allEquipment.Count)];\n                        string rarityColor = GetColorForRarity(randomItem.rarity);\n                        rewardNameText.text = $\"\u003ccolor={rarityColor}\u003e{randomItem.equipmentName}\u003c/color\u003e\";\n                    }\n                }\n                yield return null;\n            }\n\n            // 최종 결과 표시\n            gachaSlider.value = 1;\n            rewardImage.sprite = Resources.Load\u003cSprite\u003e(finalRewardData.iconPath);\n            string finalRarityColor = GetColorForRarity(finalRewardData.rarity);\n            rewardNameText.text = $\"\u003ccolor={finalRarityColor}\u003e{finalRewardData.equipmentName}\u003c/color\u003e\";\n            if (rewardDescriptionText != null) rewardDescriptionText.text = finalRewardData.description;\n            SoundManager.Instance.PlaySFX(\"SFX_System_WaveClear\");\n\n            PlayerEquipmentInstance newInstance = EquipmentManager.Instance.CreateRandomizedEquipmentInstance(finalRewardData);\n            EquipmentManager.Instance.AddEquipmentToPlayer(newInstance, false);\n        }\n        finally\n        {\n            if (gachaCloseButton != null) gachaCloseButton.SetActive(true);\n            isGachaInProgress = false;\n            UpdateRCoinDisplay();\n        }\n    }\n    \n    /// \u003csummary\u003e\n    /// 뽑기 '결과' 패널만 닫는 메소드입니다.\n    /// \u003c/summary\u003e\n    public void CloseGachaPanel()\n    {\n        // 뽑기 애니메이션 중에는 닫히지 않도록 방지\n        if (gachaAnimationPanel != null \u0026\u0026 !isGachaInProgress)\n        {\n            gachaAnimationPanel.SetActive(false);\n        }\n    }\n    \n    /// \u003csummary\u003e\n    /// 상점 패널 전체를 닫는 메소드입니다.\n    /// \u003c/summary\u003e\n    // 상점 패널을 닫는 기능을 하는 메소드\n    public void CloseShopPanel()\n    {\n        // 뽑기 애니메이션 중에는 닫히지 않도록 방지\n        if (isGachaInProgress) return;\n\n        // this.gameObject는 ShopManager.cs 스크립트가 붙어있는 'ShopPanel' 프리팹 전체를 의미합니다.\n        this.gameObject.SetActive(false);\n        SoundManager.Instance.PlaySFX(\"SFX_UI_ButtonClick\");\n    }\n    \n    private string GetColorForRarity(Rarity rarity)\n    {\n        switch (rarity)\n        {\n            case Rarity.Common: return \"#808080\";\n            case Rarity.Uncommon: return \"green\";\n            case Rarity.Rare: return \"blue\";\n            case Rarity.Epic: return \"purple\";\n            case Rarity.Legendary: return \"orange\";\n            default: return \"white\";\n        }\n    }\n}"])</script><script>self.__next_f.push([1,"15:T9bc,"])</script><script>self.__next_f.push([1,"using UnityEngine;\nusing System;\nusing System.Collections.Generic;\nusing Random = UnityEngine.Random;\n\n[CreateAssetMenu(fileName = \"Skill_StatueOfDestructionGod\", menuName = \"SpecialSkills/Passive/StatueOfDestructionGod\")]\npublic class Skill_StatueOfDestructionGod : EquipmentPassiveSkill\n{\n    [Header(\"파괴신의 조각상 설정\")]\n    [Range(0f, 1f)]\n    public float activationChance = 0.05f; // 5% 확률\n    [Range(0f, 1f)]\n    public float damagePercentage = 0.10f; // 최대 체력의 10% 데미지\n\n    // 스킬 발동 횟수를 저장할 변수\n    // NonSerialized 어트리뷰트는 플레이 모드를 종료해도 런타임에 변경된 값이 저장되지 않도록 합니다.\n    [NonSerialized]\n    public int activationCount = 0;\n    \n    public override void ApplyGameEffect()\n    {\n        // 스킬 효과가 적용될 때(게임 시작, 장착 시) 발동 횟수를 초기화\n        activationCount = 0;\n        EnemySpawner.OnEnemyKilled += OnEnemyKilled; // 적 처치 이벤트 구독\n    }\n\n    public override void RemoveGameEffect()\n    {\n        EnemySpawner.OnEnemyKilled -= OnEnemyKilled; // 적 처치 이벤트 구독 해제\n    }\n\n    private void OnEnemyKilled()\n    {\n        if (Random.value \u003c= activationChance)\n        {\n            activationCount++;\n            UIEventManager.Instance.ShowSystemMessage(SystemType.StatueOfDestructionGod);\n            SoundManager.Instance.PlaySFX(\"SFX_Skill_Explosion\");\n        \n            if (GameManager.Instance != null \u0026\u0026 GameManager.Instance.enemySpawner != null)\n            {\n                // 원본 리스트의 '복사본'을 만듭니다.\n                var enemyListCopy = new List\u003cEnemy\u003e(GameManager.Instance.enemySpawner.EnemyList);\n\n                // 이제 원본이 아닌 '복사본' 리스트를 순회하여 안전합니다.\n                foreach (Enemy enemy in enemyListCopy)\n                {\n                    if (enemy != null)\n                    {\n                        EnemyHP enemyHP = enemy.GetComponent\u003cEnemyHP\u003e();\n                        if (enemyHP != null)\n                        {\n                            enemyHP.TakeDamage(enemyHP.MaxHP * damagePercentage);\n                        }\n                    }\n                }\n            }\n            else\n            {\n                Debug.LogWarning(\"[Skill_StatueOfDestructionGod] Required references (GameManager, EnemySpawner) are null. Cannot apply damage to enemies.\");\n            }\n        }\n    }\n}\n"])</script><script>self.__next_f.push([1,"16:T5cf9,"])</script><script>self.__next_f.push([1,"using UnityEngine;\nusing System.Collections;\nusing System.Collections.Generic;\nusing TMPro;\nusing TowerDefense.Enums;\nusing UnityEngine.UI;\nusing System.Linq;\n\n/// \u003csummary\u003e\n/// 게임의 전반적인 흐름과 맵 생성을 관리하는 클래스\n/// \u003c/summary\u003e\npublic class GameManager : MonoBehaviour\n{\n    public static GameManager Instance { get; private set; }\n\n    public EnemySpawner enemySpawner; // 적 스포너 참조\n    \n    [Header(\"Required Components\")]\n    private RandomPathGenerator pathGenerator; // 랜덤 경로 생성기 참조\n    private MapGenerator mapGenerator;         // 맵 생성기 참조\n\n    public int enemiesKilled; // 처치한 적의 수\n    public float gameTime; // 게임 시간\n    public float totalDamageTaken; // 받은 총 데미지\n    public int middleBossesKilled; // 처치한 중간 보스 수\n    public int bossesKilled; // 처치한 최종 보스 수\n    public int bonusScore; // 보너스 점수\n    private MapDifficulty _currentMapDifficulty; // 현재 맵 난이도 정보\n    public GameObject currentWaveEnemyPrefabSample;\n\n    [Header(\"Real-time Score UI\")]\n    [Tooltip(\"최종 점수를 표시할 텍스트\")]\n    [SerializeField] private TMP_Text finalScoreText;\n    \n    [Header(\"Infinite Mode UI\")]\n    [Tooltip(\"무한 모드 웨이브 타이머를 포함하는 부모 패널\")]\n    [SerializeField] private GameObject infiniteModeTimerPanel; // [수정] 타이머 텍스트를 담는 패널\n    \n    [Tooltip(\"플레이어 HP 참조 (패널티 적용용)\")]\n    [SerializeField] private PlayerHP playerHP;\n    \n    public long infiniteModeScore = 0; // 무한 모드 점수 (값이 매우 커질 수 있으므로 long 사용)\n    // 무한 모드 세부 점수를 저장할 변수들\n    private long _infiniteKillScore = 0;\n    private long _infiniteWaveClearScore = 0;\n    private long _infiniteTimeBonusScore = 0;\n    \n    private TextMeshProUGUI _timerTextComponent; // [추가] 타이머 패널 하위의 텍스트 컴포넌트를 저장할 변수\n    \n    public MapDifficulty CurrentMapDifficulty =\u003e _currentMapDifficulty;\n\n    [Header(\"UI References for Buttons\")]\n    [Tooltip(\"타워 버튼 UI 프리팹\")]\n    [SerializeField] private GameObject towerButtonPrefab;\n    [Tooltip(\"스킬 버튼 UI 프리팹\")]\n    [SerializeField] private GameObject skillButtonPrefab;\n    [Tooltip(\"타워 버튼들이 배치될 UI 부모 Transform\")]\n    [SerializeField] private Transform towerButtonParent;\n    [Tooltip(\"스킬 버튼들이 배치될 UI 부모 Transform\")]\n    [SerializeField] private Transform skillButtonParent;\n    [Tooltip(\"표시할 랜덤 보상 패널의 개수\")]\n    public int numberOfRewardsToShow = 2; // 기본값 2\n    public static bool isSPRewardFixed = false; // SP 보상 고정 플래그\n    public static bool isTowerSellCostFixed = false; // 타워 판매 비용 고정 플래그\n\n    [Header(\"Data References\")]\n    [Tooltip(\"모든 타워 아키타입 ScriptableObject\")]\n    [SerializeField] private TowerArchetype[] towerArchetypes;\n    public TowerArchetype[] TowerArchetypes =\u003e towerArchetypes;\n\n    [Tooltip(\"플레이어 업그레이드 참조\")]\n    [SerializeField] private PlayerUpgrade playerUpgrade;\n    \n    public PlayerUpgrade PlayerUpgrade =\u003e playerUpgrade;\n    \n    [Tooltip(\"스킬 매니저 참조\")]\n    public SkillManager skillManager;\n    [Tooltip(\"웨이브 시스템 참조\")]\n    public WaveSystem waveSystem;\n    [Tooltip(\"타워 스포너 참조\")]\n    public TowerSpawner towerSpawner;\n    \n    [Tooltip(\"현재 게임 속도를 표시하는 UI 텍스트\")]\n    public TextMeshProUGUI textGameSpeed;\n    \n    // 생성된 버튼들을 관리할 변수\n    private List\u003cButton\u003e towerButtons = new List\u003cButton\u003e();\n    private List\u003cButton\u003e skillButtons = new List\u003cButton\u003e();\n    \n    public List\u003cButton\u003e TowerButtons =\u003e towerButtons;\n    public List\u003cButton\u003e SkillButtons =\u003e skillButtons;\n    \n    public Vector3 startCastlePosition;\n    public Vector3 endCastlePosition;\n    \n    private float gameSpeed = 1f; // 현재 게임 속도 (1x, 2x, 4x)\n\n    private void Awake()\n    {\n        if (Instance == null)\n        {\n            Instance = this;\n        }\n        else\n        {\n            Destroy(gameObject);\n        }\n        \n        ClearSceneData.Reset();\n        Time.timeScale = gameSpeed;\n    }\n    \n    private void Start()\n    {\n        // 새 게임 기본 분석정보 기록\n        if (GameAnalyticsManager.Instance != null)\n        {\n            GameAnalyticsManager.Instance.StartNewSession();\n            string mode = GameModeManager.CurrentMode == GameMode.Normal ? \"Normal\" : \"Infinite\";\n            int diff = DifficultyManager.Instance.CurrentDifficultyLevel;\n            float mapDiff = CurrentMapDifficulty != null ? CurrentMapDifficulty.TotalScore : 0;\n            GameAnalyticsManager.Instance.SetInitialGameInfo(mode, diff, mapDiff);\n        }\n        \n        PerkManager.Instance.ResetPerks();\n        \n        enemiesKilled = 0; // 게임 시작 시 초기화\n        gameTime = 0f; // 게임 시간 초기화\n        totalDamageTaken = 0f; // 받은 총 데미지 초기화\n        middleBossesKilled = 0; // 중간 보스 처치 수 초기화\n        bossesKilled = 0; // 최종 보스 처치 수 초기화\n        bonusScore = 0; // 보너스 점수 초기화\n\n        // 필요한 컴포넌트 초기화\n        pathGenerator = GetComponent\u003cRandomPathGenerator\u003e();\n        mapGenerator = GetComponent\u003cMapGenerator\u003e();\n        \n        // 게임 모드에 따라 UI 상태를 설정합니다.\n        if (GameModeManager.CurrentMode == GameMode.Infinite)\n        {\n            // 타이머 패널 하위의 Text 컴포넌트를 찾아 저장합니다.\n            if (infiniteModeTimerPanel != null)\n            {\n                _timerTextComponent = infiniteModeTimerPanel.GetComponentInChildren\u003cTextMeshProUGUI\u003e();\n                infiniteModeTimerPanel.SetActive(true);\n            }\n        }\n        else // 일반 모드\n        {\n            if (infiniteModeTimerPanel != null)\n            {\n                infiniteModeTimerPanel.SetActive(false);\n            }\n        }\n        \n        // 점수판은 항상 켜져 있도록 합니다.\n        if(finalScoreText != null) finalScoreText.gameObject.SetActive(true);\n        \n        // 게임 시작 시 새로운 맵 생성\n        GenerateNewMap();\n\n        // UI 초기화 코루틴 시작\n        StartCoroutine(InitializeGameUI());\n    }\n    \n    private void Update()\n    {\n        gameTime += Time.deltaTime;\n        \n        // [수정] 모드에 따라 다른 점수판을 업데이트\n        if (GameModeManager.CurrentMode == GameMode.Infinite)\n        {\n            if (GameModeManager.CurrentMode == GameMode.Infinite)\n            {\n                // 무한 모드일 경우: infiniteModeScore를 표시\n                finalScoreText.text = $\"점 수 : {infiniteModeScore:N0}\";\n            }\n        }\n        else\n        {\n            if (finalScoreText != null)\n            {\n                int clearedDifficultyLevel = DifficultyManager.Instance.CurrentDifficultyLevel;\n            \n                float currentScore =\n                    (clearedDifficultyLevel * 10000f) +\n                    (_currentMapDifficulty.TotalScore * 100f) +\n                    (enemiesKilled * 10f) +\n                    (totalDamageTaken * -500f) + // 받은 데미지는 감점\n                    (middleBossesKilled * 1000f) +\n                    (bossesKilled * 10000f) +\n                    (bonusScore * 1f);\n                finalScoreText.text = $\"점 수 : {currentScore:N0}\";\n            }\n        }\n    }\n\n    // 무한 모드 점수 추가 메소드들\n    public void AddScore_Infinite_Kill(int baseGold)\n    {\n        // 적 처치 점수 = (적이 주는 기본 골드 * 맵 난이도 배율)\n        long score = (long)(baseGold * _currentMapDifficulty.TotalScore * 0.01f);\n        _infiniteKillScore += score;\n        infiniteModeScore += score;\n    }\n\n    public void AddScore_Infinite_WaveClear()\n    {\n        // 웨이브 클리어 기본 점수\n        long score = (long)(100 * Mathf.Pow(1.1f, waveSystem.CurrentWave));\n        _infiniteWaveClearScore += score;\n        infiniteModeScore += score;\n    }\n\n    public void AddScore_Infinite_TimeBonus(float remainingTime)\n    {\n        // 남은 시간 1초당 1000점 (예시)\n        long score = (long)(remainingTime * 10);\n        _infiniteTimeBonusScore += score;\n        infiniteModeScore += score;\n    }\n    \n    private IEnumerator InitializeGameUI()\n    {\n        // 필요한 매니저들이 준비될 때까지 대기\n        yield return new WaitUntil(() =\u003e EquipmentManager.IsReady \u0026\u0026 playerUpgrade != null \u0026\u0026 skillManager != null \u0026\u0026 towerSpawner != null);\n        \n        // 타워 버튼 생성 및 설정\n        for (int i = 0; i \u003c towerArchetypes.Length; i++)\n        {\n            if (towerArchetypes[i] == null) continue;\n            SetupButton(towerButtonPrefab, towerButtonParent, towerArchetypes[i], true, i);\n        }\n        \n        // 스킬 버튼 생성 및 설정\n        for (int i = 0; i \u003c towerArchetypes.Length; i++)\n        {\n            if (towerArchetypes[i] == null || towerArchetypes[i].skillPrefab == null) continue;\n            SetupButton(skillButtonPrefab, skillButtonParent, towerArchetypes[i], false, i);\n        }\n    }\n\n    /// \u003csummary\u003e\n    /// 인게임 '시작' 버튼을 눌렀을 때 호출될 통합 메소드입니다.\n    /// \u003c/summary\u003e\n    public void StartGameFlow()\n    {\n        Time.timeScale = gameSpeed;\n        \n        // 시작 버튼을 찾아서 비활성화합니다. (중복 클릭 방지)\n        // 버튼 이름이 \"ButtonStartWave\"라고 가정합니다. 실제 이름에 맞게 수정해주세요.\n        GameObject startButton = GameObject.Find(\"ButtonStartWave\");\n        if (startButton != null)\n        {\n            startButton.SetActive(false);\n        }\n\n        // 현재 게임 모드를 확인하고 그에 맞는 게임 루프를 시작합니다.\n        if (GameModeManager.CurrentMode == GameMode.Infinite)\n        {\n            // 무한 모드 일때는 타워 코스트 보상이 0\n            PerkManager.Instance.perk_towerCostPerWave = 0;\n            \n            StartCoroutine(InfiniteModeLoop());\n        }\n        else // 일반 모드\n        {\n            waveSystem.StartWave();\n        }\n    }\n    \n    /// \u003csummary\u003e\n    /// 타워 또는 스킬 버튼을 설정하는 헬퍼 메서드\n    /// \u003c/summary\u003e\n    /// \u003cparam name=\"prefab\"\u003e버튼 프리팹\u003c/param\u003e\n    /// \u003cparam name=\"parent\"\u003e버튼이 배치될 부모 Transform\u003c/param\u003e\n    /// \u003cparam name=\"archetype\"\u003e관련된 TowerArchetype\u003c/param\u003e\n    /// \u003cparam name=\"isTowerButton\"\u003e타워 버튼인지 스킬 버튼인지 여부\u003c/param\u003e\n    private void SetupButton(GameObject prefab, Transform parent, TowerArchetype archetype, bool isTowerButton, int index)\n    {\n        GameObject buttonGO = Instantiate(prefab, parent);\n\n        // 이미지 설정\n        string imageName = isTowerButton ? \"ImageTower\" : \"ImageSkill\";\n        Transform imageTransform = buttonGO.transform.Find(imageName);\n        if (imageTransform != null)\n        {\n            Image buttonImage = imageTransform.GetComponent\u003cImage\u003e();\n            Sprite icon = isTowerButton ? archetype.towerIcon : archetype.skillIcon;\n            if (buttonImage != null \u0026\u0026 icon != null) buttonImage.sprite = icon;\n        }\n\n        // 텍스트 설정\n        TextMeshProUGUI buttonText = buttonGO.GetComponentInChildren\u003cTextMeshProUGUI\u003e();\n        if (buttonText != null)\n        {\n            if (isTowerButton)\n            {\n                buttonText.text = $\"{archetype.towerWeaponStats.cost}\"; \n            }\n            else\n            {\n                buttonText.text = $\"\u003ccolor=blue\u003e{archetype.skillPointCost}SP\u003c/color\u003e\";\n            }\n        }\n\n        // TooltipTrigger 설정\n        TooltipTrigger tooltipTrigger = buttonGO.GetComponent\u003cTooltipTrigger\u003e();\n        if (tooltipTrigger == null)\n        {\n            tooltipTrigger = buttonGO.AddComponent\u003cTooltipTrigger\u003e();\n        }\n        tooltipTrigger.SetHeader(isTowerButton ? archetype.archetypeDisplayName : archetype.skillDisplayName);\n        tooltipTrigger.GetContentCallback = () =\u003e\n        {\n            return isTowerButton ?\n                archetype.GetFormattedTowerDescription(playerUpgrade, EquipmentManager.Instance.currentPlayerData) :\n                archetype.GetFormattedSkillDescription(playerUpgrade, EquipmentManager.Instance.currentPlayerData);\n        };\n\n        // 클릭 이벤트 연결\n        UnityEngine.UI.Button uiButton = buttonGO.GetComponent\u003cUnityEngine.UI.Button\u003e();\n        if (isTowerButton)\n        {\n            uiButton.onClick.AddListener(() =\u003e towerSpawner.ReadyToSpawnTower(buttonGO.transform, archetype, false)); // 일반 타워\n            towerButtons.Add(uiButton);\n        }\n        else\n        {\n            uiButton.onClick.AddListener(() =\u003e skillManager.UseSkill(buttonGO.transform, archetype));\n            skillManager.RegisterSkillButton(archetype.archetypeID, uiButton, index); // SkillManager에 버튼 등록\n            skillButtons.Add(uiButton);\n        }\n    }\n\n    /// \u003csummary\u003e\n    /// 새로운 맵을 생성하고 관련 컴포넌트들을 설정합니다。\n    /// 이 메소드는 웨이브 시스템에서 다음 스테이지로 넘어갈 때 호출될 수 있습니다。\n    /// \u003c/summary\u003e\n    [ContextMenu(\"Generate New Map\")] // 유니티 에디터에서 쉽게 호출할 수 있도록 ContextMenu 추가\n    public void GenerateNewMap() {\n        // 1. 랜덤 경로 생성\n        Vector2Int[] path = pathGenerator.GenerateWaypoints();\n        bool isLeftToRight = pathGenerator.IsLeftToRight;\n        \n        // 2. 맵 난이도 계산 및 저장\n        _currentMapDifficulty = MapDifficulty.CalculateDifficulty(path, pathGenerator.SegmentCount);\n        // Debug.Log($\"맵 난이도: {_currentMapDifficulty.TotalScore}\");\n\n        // 3. 생성된 경로를 기반으로 맵 타일 생성\n        mapGenerator.GenerateMap(path, isLeftToRight);\n\n        // 4. 생성된 경로 정보를 적 스포너에 전달하여 적 이동 경로 설정\n        enemySpawner.SetupWaypoints(path);\n    }\n    \n    /// \u003csummary\u003e\n    /// '희생 전략' 특성에 의해 선택된 타워와 스킬 UI 버튼을 비활성화합니다.\n    /// \u003c/summary\u003e\n    /// \u003cparam name=\"towerIndex\"\u003e비활성화할 타워의 인덱스\u003c/param\u003e\n    public void DisableSacrificedTowerUI(int towerIndex)\n    {\n        if (PerkManager.Instance == null || !PerkManager.Instance.perk_isSacrificeEnabled)\n        {\n            // 특성이 활성화되지 않았다면, 이 메서드가 호출되었더라도 아무것도 하지 않고 즉시 종료합니다.\n            return;\n        }\n        \n        // 타워 버튼 비활성화\n        if (towerIndex \u003e= 0 \u0026\u0026 towerIndex \u003c towerButtons.Count)\n        {\n            // [수정] SetActive(false) 대신 interactable을 false로 변경\n            towerButtons[towerIndex].interactable = false;\n        }\n\n        // 스킬 버튼 비활성화\n        if (towerIndex \u003e= 0 \u0026\u0026 towerIndex \u003c skillButtons.Count)\n        {\n            // [수정] SetActive(false) 대신 interactable을 false로 변경\n            skillButtons[towerIndex].interactable = false;\n        }\n    \n        // Debug.Log($\"Sacrifice Perk Activated: Tower/Skill at index {towerIndex} has been disabled.\");\n    }\n    \n    /// \u003csummary\u003e\n    /// 게임 속도를 다음 단계로 변경합니다. (1x -\u003e 2x -\u003e 4x -\u003e 1x 순환)\n    /// \u003c/summary\u003e\n    public void SpeedUp()\n    {\n        // 게임 속도 변경 로직\n        if (gameSpeed == 1f)\n        {\n            gameSpeed = 2f;\n        }\n        else if (gameSpeed == 2f)\n        {\n            gameSpeed = 4f;\n        }\n        else\n        {\n            gameSpeed = 1f;\n        }\n\n        // UI 텍스트 업데이트 및 실제 게임 속도 적용\n        textGameSpeed.text = gameSpeed.ToString() + \"x\";\n        Time.timeScale = gameSpeed;\n    }\n    \n    /// \u003csummary\u003e\n    /// 무한 모드의 메인 게임 루프를 관리하는 코루틴입니다.\n    /// \u003c/summary\u003e\n    private IEnumerator InfiniteModeLoop()\n    {\n        while (playerHP.CurrentHP \u003e 0)\n        {\n            waveSystem.StartNextInfiniteWave();\n            float waveTimer = 120f;\n\n            while (waveTimer \u003e 0)\n            {\n                waveTimer -= Time.deltaTime;\n                \n                // 캐시해둔 텍스트 컴포넌트를 업데이트합니다.\n                if (_timerTextComponent != null)\n                {\n                    int minutes = (int)waveTimer / 60;\n                    int seconds = (int)waveTimer % 60;\n                    _timerTextComponent.text = $\"{minutes:00}:{seconds:00}\";\n                }\n                \n                if (enemySpawner.ActiveEnemyCount == 0 \u0026\u0026 enemySpawner.SpawnEnemyCount \u003e= waveSystem.GetCurrentWaveMaxEnemies())\n                {\n                    // 점수 추가 로직 (기존과 동일)\n                    AddScore_Infinite_WaveClear();\n                    AddScore_Infinite_TimeBonus(waveTimer);\n\n                    // 타이머 루프를 빠져나가 다음 웨이브로 진행\n                    break;\n                }\n                yield return null;\n            }\n            \n            // 먼저 타임 오버 시 패널티를 적용합니다.\n            if (waveTimer \u003c= 0)\n            {\n                int remainingEnemies = enemySpawner.ActiveEnemyCount;\n                if (remainingEnemies \u003e 0)\n                {\n                    playerHP.TakeDamage(remainingEnemies);\n                }\n            }\n        \n            // 패널티 적용 후에도 플레이어가 살아있는지 확인합니다.\n            if (playerHP.CurrentHP \u003c= 0)\n            {\n                break; // 루프를 탈출하여 게임 오버 처리\n            }\n\n            // 웨이브 시작 전 남은 적 처리\n            enemySpawner.ClearAllEnemies();\n            \n            // 살아있다면, 이제 모든 경우에 보상 패널을 호출하고 선택을 기다립니다.\n            waveSystem.WaveReward();\n            yield return new WaitUntil(() =\u003e !waveSystem.isWaitingForRewardSelection);\n\n            // 다음 웨이브 시작 전 짧은 대기 시간\n            UIEventManager.Instance.ShowSystemMessage(SystemType.WaveStart);\n            yield return new WaitForSecondsRealtime(3f);\n        }\n        \n        EndInfiniteModeRun();\n    }\n    \n    /// \u003csummary\u003e\n    /// 무한 모드 게임 오버 시 호출될 메소드\n    /// \u003c/summary\u003e\n    private void EndInfiniteModeRun()\n    {\n        Time.timeScale = 0f; // 게임 정지\n\n        // 무한 모드 종료 시 데이터 수집 및 전송\n        if (GameAnalyticsManager.Instance != null)\n        {\n            // 샘플 몬스터 정보로 최종 몬스터 정보 저장\n            List\u003cobject\u003e finalEnemies = new List\u003cobject\u003e();\n            if (currentWaveEnemyPrefabSample != null)\n            {\n                var enemyInfo = currentWaveEnemyPrefabSample.GetComponent\u003cEnemy\u003e();\n                var enemyHP = currentWaveEnemyPrefabSample.GetComponent\u003cEnemyHP\u003e();\n                if (enemyInfo != null \u0026\u0026 enemyHP != null)\n                {\n                    finalEnemies.Add(new {\n                        type = enemyInfo.enemyType.ToString(),\n                        hp = enemyHP.MaxHP, // 샘플이므로 MaxHP를 기록\n                        physicDef = enemyHP.CurrentPhysicArmor,\n                        magicDef = enemyHP.CurrentMagicArmor\n                    });\n                }\n            }\n            GameAnalyticsManager.Instance.SetFinalWaveEnemies(finalEnemies);\n            \n            // 무한 모드 세부 점수를 정확하게 기록\n            GameAnalyticsManager.Instance.RecordScoreDetail(\"killScore\", _infiniteKillScore);\n            GameAnalyticsManager.Instance.RecordScoreDetail(\"waveClearScore\", _infiniteWaveClearScore);\n            GameAnalyticsManager.Instance.RecordScoreDetail(\"timeBonusScore\", _infiniteTimeBonusScore);\n            GameAnalyticsManager.Instance.RecordScoreDetail(\"reachedWave\", waveSystem.CurrentWave);\n            \n            // --- 최종 데이터 설정 ---\n            GameAnalyticsManager.Instance.SetFinalUpgradeLevels(playerUpgrade.physicUpgrade, playerUpgrade.magicUpgrade);\n            CollectAndSetFinalEquipmentStats();\n            CollectAndSetFinalTowerDps();\n\n            // --- 데이터 전송 ---\n            GameAnalyticsManager.Instance.FinalizeAndSendEvent(\"N/A\", waveSystem.CurrentWave, infiniteModeScore);\n        }\n        \n        // ClearSceneData에 무한 모드 결과 데이터를 저장\n        ClearSceneData.IsInfiniteModeResult = true; // 무한 모드 결과임을 알림\n        ClearSceneData.InfiniteModeScore = infiniteModeScore;\n        ClearSceneData.ReachedWave = waveSystem.CurrentWave;\n\n        // 결과창으로 이동\n        LoadingSceneController.LoadScene(\"ClearScene\");\n    }\n    \n    // 데이터 분석 관련 메소드\n    private void CollectAndSetFinalEquipmentStats()\n    {\n        if (EquipmentManager.Instance == null || EquipmentManager.Instance.currentPlayerData == null) return;\n\n        var playerData = EquipmentManager.Instance.currentPlayerData;\n\n        // 2. PlayerData에 최종 합산된 모든 스탯 정보들을 Dictionary 형태로 수집합니다.\n        Dictionary\u003cstring, object\u003e finalAggregatedStats = new Dictionary\u003cstring, object\u003e\n        {\n            // 글로벌 스탯 (곱연산 보너스 %)\n            { \"attackDamage_Mul\", playerData.attackDamage },\n            { \"attackSpeed_Mul\", playerData.attackSpeed },\n            { \"attackRange_Mul\", playerData.attackRange },\n            { \"skillDamage_Mul\", playerData.skillDamage },\n        \n            // 타워 개별 데미지 증가량 (곱연산 보너스 %)\n            { \"defaultTowerDamage_Mul\", playerData.defaultTowerDamage },\n            { \"arrowTowerDamage_Mul\", playerData.arrowTowerDamage },\n            { \"laserTowerDamage_Mul\", playerData.laserTowerDamage },\n            { \"priestsTowerDamage_Mul\", playerData.priestsTowerDamage },\n            { \"spearTowerDamage_Mul\", playerData.spearTowerDamage },\n            { \"swordTowerDamage_Mul\", playerData.swordTowerDamage },\n        \n            // 부가 스탯 (합연산)\n            { \"goldPerSecond\", playerData.goldPerSecond },\n            { \"finalMaxHP\", playerData.maxHP }, // 장비 효과가 적용된 최종 MaxHP\n            { \"finalStartSP\", playerData.startSP },\n            { \"finalMaxSP\", playerData.maxSP },\n            { \"finalStartGold\", playerData.startGold }\n        };\n\n        // 3. 수집된 장비 이름 리스트와 최종 스탯 딕셔너리를 분석 매니저로 보냅니다.\n        GameAnalyticsManager.Instance.SetFinalEquipment(new List\u003cstring\u003e(), finalAggregatedStats);\n    }\n\n    private void CollectAndSetFinalTowerDps()\n    {\n        Dictionary\u003cstring, float\u003e dpsDict = new Dictionary\u003cstring, float\u003e();\n        GameObject[] towers = GameObject.FindGameObjectsWithTag(\"Tower\");\n        foreach (var towerGO in towers)\n        {\n            var weapon = towerGO.GetComponent\u003cTowerWeapon\u003e();\n            if (weapon != null)\n            {\n                // \"타워이름_고유ID\" 형태로 저장하여 구분\n                string uniqueTowerID = $\"{weapon.towerArchetype.archetypeDisplayName}_{towerGO.GetInstanceID()}\";\n                dpsDict[uniqueTowerID] = weapon.Damage;\n            }\n        }\n        GameAnalyticsManager.Instance.SetFinalTowerDps(dpsDict);\n    }\n\n    public TowerArchetype GetTowerArchetypeByName(string name)\n    {\n       return towerArchetypes.FirstOrDefault(a =\u003e a.archetypeDisplayName == name);\n    }\n}"])</script><script>self.__next_f.push([1,"17:T1ad3,"])</script><script>self.__next_f.push([1,"using UnityEngine;\nusing System.IO;\nusing System.Text; // 암호화를 위해 System.Text\nusing System;     // Action 이벤트를 위해 필요 (PlayerData 로드 이벤트용)\n\npublic class GameDataManager : MonoBehaviour\n{\n    public static GameDataManager Instance { get; private set; }\n    public static bool IsReady { get; private set; }\n\n    private string savePath; // 저장 경로\n    \n    // 암호화에 사용할 비밀 키\n    private readonly string encryptionKey = \"???\";\n\n    private void Awake()\n    {\n        if (Instance == null)\n        {\n            Instance = this;\n            DontDestroyOnLoad(gameObject);\n            IsReady = false; // 준비 안됨으로 초기화\n\n            // Application.persistentDataPath의 상위 디렉토리 (LocalLow)를 가져옴\n            string baseAppDataPath = Path.GetDirectoryName(Path.GetDirectoryName(Application.persistentDataPath));\n            // 원하는 게임 저장 디렉토리 경로를 구성\n            string gameSaveDirectory = Path.Combine(baseAppDataPath, \"RogueTower\");\n\n            // 저장 디렉토리가 없으면 생성\n            if (!Directory.Exists(gameSaveDirectory))\n            {\n                Directory.CreateDirectory(gameSaveDirectory);\n            }\n\n            savePath = Path.Combine(gameSaveDirectory, \"playerData.json\");\n            // Debug.Log($\"저장 경로: {savePath}\");\n\n            IsReady = true; // 모든 준비 완료\n        }\n        else\n        {\n            Destroy(gameObject);\n        }\n    }\n\n    /// \u003csummary\u003e\n    /// 플레이어 데이터를 파일에 저장합니다.\n    /// \u003c/summary\u003e\n    /// \u003cparam name=\"playerData\"\u003e저장할 PlayerData 객체\u003c/param\u003e\n    public void SavePlayerData(PlayerData playerData)\n    {\n        string json = JsonUtility.ToJson(playerData, true);\n        //File.WriteAllText(savePath, json);\n        \n        // JSON 데이터를 파일에 저장하기 전에 암호화합니다.\n        string encryptedJson = EncryptDecrypt(json);\n        \n        // 암호화된 데이터를 파일에 씁니다.\n        File.WriteAllText(savePath, encryptedJson);\n    }\n\n    /// \u003csummary\u003e\n    /// [수정] 파일에서 플레이어 데이터를 불러옵니다. 구버전(암호화 안됨) 데이터의 마이그레이션을 지원합니다.\n    /// \u003c/summary\u003e\n    /// \u003creturns\u003e불러온 PlayerData 객체, 파일이 없으면 새로운 PlayerData 객체 반환\u003c/returns\u003e\n    public PlayerData LoadPlayerData()\n    {\n        // PlayerData를 담을 변수를 미리 선언합니다.\n        PlayerData loadedData;\n\n        if (File.Exists(savePath))\n        {\n            // 일단 파일의 모든 내용을 문자열로 읽어옵니다.\n            string fileContents = File.ReadAllText(savePath);\n\n            try\n            {\n                // 1. 먼저, 데이터가 '암호화된 최신 버전'이라고 가정하고 복호화를 시도합니다.\n                string decryptedJson = EncryptDecrypt(fileContents);\n                loadedData = JsonUtility.FromJson\u003cPlayerData\u003e(decryptedJson);\n                \n                // JsonUtility가 null을 반환하는 경우(파일 내용이 있지만 유효한 JSON이 아님)를 대비하여 예외를 발생시킵니다.\n                if (loadedData == null)\n                {\n                    throw new System.Exception(\"Decrypted data is not valid JSON.\");\n                }\n\n                // Debug.Log(\"암호화된 최신 세이브 파일을 성공적으로 불러왔습니다.\");\n            }\n            catch (System.Exception)\n            {\n                // 2. 복호화 또는 JSON 파싱에 실패하면, '암호화되지 않은 구버전' 데이터로 간주합니다.\n                Debug.LogWarning(\"데이터 복호화 실패, 구버전 세이브 파일로 간주하고 마이그레이션을 시도합니다.\");\n                \n                try\n                {\n                    // 파일 내용을 일반 JSON 텍스트로 다시 파싱합니다.\n                    loadedData = JsonUtility.FromJson\u003cPlayerData\u003e(fileContents);\n\n                    if (loadedData != null)\n                    {\n                        // [핵심] 즉시 새로운 암호화된 파일로 다시 저장하여 데이터를 최신 버전으로 마이그레이션합니다.\n                        SavePlayerData(loadedData);\n                        Debug.Log(\"구버전 데이터를 최신 암호화 버전으로 마이그레이션하고 저장했습니다.\");\n                    }\n                    else\n                    {\n                        // 구버전 데이터조차 파싱할 수 없다면, 파일이 손상된 것입니다.\n                        Debug.LogError(\"세이브 파일이 손상되어 데이터를 읽을 수 없습니다. 새로운 데이터를 생성합니다.\");\n                        loadedData = new PlayerData();\n                    }\n                }\n                catch (System.Exception innerEx)\n                {\n                    // 구버전 데이터 파싱도 실패하는 최악의 경우\n                    Debug.LogError($\"구버전 데이터 파싱에도 실패했습니다. 파일이 심각하게 손상되었습니다. 오류: {innerEx.Message}\");\n                    loadedData = new PlayerData();\n                }\n            }\n        }\n        else\n        {\n            // 세이브 파일이 없으면 새로 생성\n            Debug.LogWarning(\"저장된 플레이어 데이터가 없습니다. 새로운 데이터 생성.\");\n            loadedData = new PlayerData();\n        }\n        \n        // --- 불러온 데이터 안전성 검사 (기존 코드 유지) ---\n        if (loadedData.ownedEquipmentInstances == null)\n        {\n            loadedData.ownedEquipmentInstances = new System.Collections.Generic.List\u003cPlayerEquipmentInstance\u003e();\n        }\n        if (loadedData.equippedSlots == null || loadedData.equippedSlots.Count == 0)\n        {\n            loadedData.equippedSlots = new System.Collections.Generic.List\u003cEquipmentSlotEntry\u003e();\n            foreach (EquipmentType type in System.Enum.GetValues(typeof(EquipmentType)))\n            {\n                loadedData.equippedSlots.Add(new EquipmentSlotEntry(type, null));\n            }\n        }\n\n        // 최종적으로 처리된 PlayerData 객체를 반환합니다.\n        return loadedData;\n    }\n    \n    /// \u003csummary\u003e\n    /// XOR 연산을 사용하여 문자열을 암호화하거나 복호화합니다.\n    /// \u003c/summary\u003e\n    private string EncryptDecrypt(string data)\n    {\n        StringBuilder result = new StringBuilder();\n        for (int i = 0; i \u003c data.Length; i++)\n        {\n            // 데이터의 각 문자를 키의 문자와 XOR 연산합니다.\n            result.Append((char)(data[i] ^ encryptionKey[i % encryptionKey.Length]));\n        }\n        return result.ToString();\n    }\n}\n"])</script><script>self.__next_f.push([1,"18:T3820,"])</script><script>self.__next_f.push([1,"using System.Collections;\nusing UnityEngine;\nusing UnityEngine.SceneManagement;\nusing UnityEngine.InputSystem;\nusing UnityEngine.UI;\n\n/// \u003csummary\u003e\n/// 게임 내 UI 패널의 표시, 전환, 애니메이션을 관리하는 클래스\n/// \u003c/summary\u003e\npublic class UIManager : MonoBehaviour\n{\n    [Header(\"UI Panels\")]\n    [Tooltip(\"타워 선택 패널의 RectTransform\")]\n    public RectTransform TowerPanel;\n    [Tooltip(\"스킬 선택 패널의 RectTransform\")]\n    public RectTransform SkillPanel;\n    [Tooltip(\"설정 패널 GameObject\")]\n    public GameObject panelMenu;\n    [Tooltip(\"메뉴 버튼\")]\n    public Button buttonMenu;\n\n    public Sprite buttonSpriteOpen;\n    public Sprite buttonSpriteClose;\n\n    public GameObject scorePanel;\n    public GameObject timePanel;\n    \n    [Tooltip(\"게임 매니저 참조\")]\n    public GameManager gameManager; // GameManager 참조 추가\n\n    private bool switchState = false; // 현재 활성화된 패널 상태 (false: TowerPanel, true: SkillPanel)\n    private bool isSwitching = false; // 패널 전환 애니메이션 진행 중 여부\n    private bool isPanelMenu = false; // 설정 패널 활성화 여부\n    private bool isUIVisible = true; // 하단 UI 그룹의 가시성 여부\n    private bool isAnimating = false; // UI 표시/숨김 애니메이션 진행 중 여부\n    \n    [Header(\"Bottom UI Elements\")]\n    [Tooltip(\"하단 UI 그룹의 부모 GameObject\")]\n    public GameObject bottomUIGroup;\n    [Tooltip(\"하단 UI 그룹 내의 모든 패널 RectTransform 배열\")]\n    public RectTransform[] bottomUIPanels;\n    \n    // 새로 추가할 변수\n    [Header(\"Animation Settings\")]\n    [Range(0.1f, 2f)]\n    [Tooltip(\"UI 애니메이션의 총 지속 시간 (초)\")]\n    public float animationDuration = 0.15f; // 0.15초 동안 애니메이션이 재생되도록 설정\n\n    private Vector2[] originalPositions;  // 각 하단 UI 패널의 초기 위치 저장\n    private Vector2 towerPanelOriginalPos;  // TowerPanel의 초기 위치\n    private Vector2 skillPanelOriginalPos;  // SkillPanel의 초기 위치\n    private float hideOffset = -350f;     // UI를 숨길 때 이동할 Y축 거리\n    \n    private void Start()\n    {\n        // 모든 하단 UI 패널의 초기 위치 저장\n        originalPositions = new Vector2[bottomUIPanels.Length];\n        for(int i = 0; i \u003c bottomUIPanels.Length; i++)\n        {\n            originalPositions[i] = bottomUIPanels[i].anchoredPosition;\n        }\n\n        // 타워/스킬 패널의 초기 위치도 따로 저장\n        towerPanelOriginalPos = TowerPanel.anchoredPosition;\n        skillPanelOriginalPos = SkillPanel.anchoredPosition;\n        \n        // 게임 시작 시 스킬 패널을 아래로 숨김\n        SkillPanel.anchoredPosition += new Vector2(0, hideOffset);\n        \n        // 초기 상태 설정\n        switchState = false;\n    }\n\n    private void Update()\n    {\n        // 숫자 키 (1-6)를 이용한 타워/스킬 사용\n        if (Input.GetKeyDown(KeyCode.Alpha1)) HandleArchetypeInput(0);\n        if (Input.GetKeyDown(KeyCode.Alpha2)) HandleArchetypeInput(1);\n        if (Input.GetKeyDown(KeyCode.Alpha3)) HandleArchetypeInput(2);\n        if (Input.GetKeyDown(KeyCode.Alpha4)) HandleArchetypeInput(3);\n        if (Input.GetKeyDown(KeyCode.Alpha5)) HandleArchetypeInput(4);\n        if (Input.GetKeyDown(KeyCode.Alpha6)) HandleArchetypeInput(5);\n\n        // 'T' 키로 타워 패널 전환\n        if (Keyboard.current.tKey.wasPressedThisFrame)\n        {\n            SwitchTowerPanel();\n        }\n\n        // 'S' 키로 스킬 패널 전환\n        if (Keyboard.current.sKey.wasPressedThisFrame)\n        {\n            SwitchSkillPanel();\n        }\n\n        // 'Tab' 키로 하단 UI 그룹 토글 (표시/숨김)\n        if (Keyboard.current.tabKey.wasPressedThisFrame)\n        {\n            ToggleUI();\n        }\n\n        // 'Q' 키로 게임속도 단축키\n        if (Keyboard.current.qKey.wasPressedThisFrame)\n        {\n            GameManager.Instance.SpeedUp();\n        }\n        \n        // 'Escape' 키 처리\n        if (Keyboard.current.escapeKey.wasPressedThisFrame)\n        {\n            // 설정 패널이 열려있으면 닫기\n            if(isPanelMenu)\n            {\n                ButtonMenu();\n            }\n            // 하단 UI가 숨겨져 있으면 다시 표시\n            else if(!isUIVisible)  \n            {\n                ToggleUI();\n            }\n        }\n    }\n\n    private void HandleArchetypeInput(int index)\n    {\n        var buttonList = !switchState ? gameManager.TowerButtons : gameManager.SkillButtons;\n\n        if (buttonList != null \u0026\u0026 index \u003c buttonList.Count)\n        {\n            Button targetButton = buttonList[index];\n            if (targetButton != null \u0026\u0026 targetButton.interactable)\n            {\n                targetButton.onClick.Invoke();\n            }\n        }\n    }\n\n    /// \u003csummary\u003e\n    /// 타워 패널로 전환합니다.\n    /// \u003c/summary\u003e\n    public void SwitchTowerPanel()\n    {\n        // 이미 타워 패널이 활성화되어 있거나 전환 애니메이션 중이면 무시\n        if (!switchState || isSwitching)\n        {\n            return;\n        }\n        switchState = false; // 타워 패널 상태로 설정\n        StartCoroutine(SwitchPanel(TowerPanel, SkillPanel)); // 패널 전환 애니메이션 시작\n    }\n\n    /// \u003csummary\u003e\n    /// 스킬 패널로 전환합니다.\n    /// \u003c/summary\u003e\n    public void SwitchSkillPanel()\n    {\n        // 이미 스킬 패널이 활성화되어 있거나 전환 애니메이션 중이면 무시\n        if (switchState || isSwitching)\n        {\n            return;\n        }\n        switchState = true; // 스킬 패널 상태로 설정\n        StartCoroutine(SwitchPanel(SkillPanel,TowerPanel)); // 패널 전환 애니메이션 시작\n    }\n\n    /// \u003csummary\u003e\n    /// 설정 패널을 토글합니다. (열기/닫기)\n    /// \u003c/summary\u003e\n    public void ButtonMenu()\n    {\n        isPanelMenu = !isPanelMenu;\n        panelMenu.SetActive(isPanelMenu);\n\n        if (isPanelMenu)\n        {\n            buttonMenu.GetComponent\u003cImage\u003e().sprite = buttonSpriteClose;\n        }\n        else\n        {\n            buttonMenu.GetComponent\u003cImage\u003e().sprite = buttonSpriteOpen;\n        }\n        \n        SoundManager.Instance.PlaySFX(\"SFX_UI_PanelOpen\"); // UI 버튼 클릭 사운드 재생\n    }\n\n    public void ButtonHome()\n    {\n        SoundManager.Instance.PlaySFX(\"SFX_UI_ButtonClick\"); // UI 버튼 클릭 사운드 재생\n        SceneManager.LoadScene(\"Lobby\");\n    }\n    \n    public void ButtonWaitingRoom()\n    {\n        SoundManager.Instance.PlaySFX(\"SFX_UI_ButtonClick\"); // UI 버튼 클릭 사운드 재생\n        SceneManager.LoadScene(\"WaitingRoom\");\n    }\n    \n    /// \u003csummary\u003e\n    /// 현재 씬을 다시 로드하여 게임을 재시작합니다.\n    /// \u003c/summary\u003e\n    public void ButtonRetry()\n    {\n        SoundManager.Instance.PlaySFX(\"SFX_UI_ButtonClick\"); // UI 버튼 클릭 사운드 재생\n        LoadingSceneController.LoadScene(SceneManager.GetActiveScene().name);\n    }\n    \n    /// \u003csummary\u003e\n    /// 하단 UI 그룹의 가시성을 토글합니다. (표시/숨김)\n    /// \u003c/summary\u003e\n    private void ToggleUI()\n    {\n        // 애니메이션 진행 중이면 무시\n        if(isAnimating || isSwitching) return;\n\n        isUIVisible = !isUIVisible;\n        \n        if(isUIVisible)\n        {\n            bottomUIGroup.SetActive(true); // UI 그룹 활성화\n            StartCoroutine(ShowUIAnimation()); // UI 표시 애니메이션 시작\n        }\n        else\n        {\n            StartCoroutine(HideUIAnimation()); // UI 숨김 애니메이션 시작\n        }\n        \n        SoundManager.Instance.PlaySFX(\"SFX_UI_Switching\");\n    }\n    \n   /// \u003csummary\u003e\n   /// 하단 UI 그룹을 부드럽게 표시하는 애니메이션 코루틴 (수정된 버전)\n   /// \u003c/summary\u003e\n   private IEnumerator ShowUIAnimation()\n   { \n       isAnimating = true;\n       bottomUIGroup.SetActive(true);\n       \n       float elapsedTime = 0f;\n\n       // 애니메이션 시작 시점의 위치들을 저장\n       Vector2[] startPositions = new Vector2[bottomUIPanels.Length];\n       for(int i = 0; i \u003c bottomUIPanels.Length; i++)\n       {\n           startPositions[i] = bottomUIPanels[i].anchoredPosition;\n       }\n       \n       // switchState를 기반으로 각 패널의 최종 목표 위치를 동적으로 계산합니다.\n       Vector2[] targetPositions = new Vector2[bottomUIPanels.Length];\n       for(int i=0; i \u003c bottomUIPanels.Length; i++)\n       {\n           // 기본적으로는 원래 저장된 위치를 목표로 설정\n           targetPositions[i] = originalPositions[i]; \n\n           // 만약 현재 패널이 TowerPanel이라면\n           if (bottomUIPanels[i] == TowerPanel)\n           {\n               // switchState가 false(타워 활성)일 때만 원래 위치로, 아니면 숨김 위치로 설정\n               targetPositions[i] = !switchState ? towerPanelOriginalPos : towerPanelOriginalPos + new Vector2(0, hideOffset);\n           }\n           // 만약 현재 패널이 SkillPanel이라면\n           else if (bottomUIPanels[i] == SkillPanel)\n           {\n               // switchState가 true(스킬 활성)일 때만 원래 위치로, 아니면 숨김 위치로 설정\n               targetPositions[i] = switchState ? skillPanelOriginalPos : skillPanelOriginalPos + new Vector2(0, hideOffset);\n           }\n       }\n       \n       while(elapsedTime \u003c animationDuration)\n       {\n           elapsedTime += Time.deltaTime;\n           float progress = Mathf.Clamp01(elapsedTime / animationDuration);\n\n           // 모든 패널을 동시에 계산된 목표 위치로 움직임\n           for(int i = 0; i \u003c bottomUIPanels.Length; i++)\n           {\n               bottomUIPanels[i].anchoredPosition = Vector2.Lerp(startPositions[i], targetPositions[i], progress);\n           }\n           yield return null;\n       }\n       \n       // 애니메이션 종료 후 정확한 위치로 고정\n       for(int i = 0; i \u003c bottomUIPanels.Length; i++)\n       {\n           bottomUIPanels[i].anchoredPosition = targetPositions[i];\n       }\n\n       if (scorePanel != null)\n       {\n           scorePanel.SetActive(true);\n       }\n\n       if (timePanel != null \u0026\u0026 GameModeManager.CurrentMode == GameMode.Infinite)\n       {\n           timePanel.SetActive(true);\n       }\n       \n       isAnimating = false;\n   }\n\n   /// \u003csummary\u003e\n   /// 하단 UI 그룹을 부드럽게 숨기는 애니메이션 코루틴 (프레임률 독립적으로 수정)\n   /// \u003c/summary\u003e\n   private IEnumerator HideUIAnimation()\n   {\n       isAnimating = true;\n       \n       float elapsedTime = 0f;\n\n       // 시작 위치와 목표 위치를 미리 계산\n       Vector2[] startPositions = new Vector2[bottomUIPanels.Length];\n       Vector2[] targetPositions = new Vector2[bottomUIPanels.Length];\n       for(int i = 0; i \u003c bottomUIPanels.Length; i++)\n       {\n           startPositions[i] = bottomUIPanels[i].anchoredPosition;\n           targetPositions[i] = originalPositions[i] + new Vector2(0, hideOffset);\n       }\n\n       while(elapsedTime \u003c animationDuration)\n       {\n           elapsedTime += Time.deltaTime;\n           float progress = Mathf.Clamp01(elapsedTime / animationDuration);\n\n           // 모든 패널을 동시에 움직임\n           for(int i = 0; i \u003c bottomUIPanels.Length; i++)\n           {\n               bottomUIPanels[i].anchoredPosition = Vector2.Lerp(startPositions[i], targetPositions[i], progress);\n           }\n           yield return null;\n       }\n       \n       // 애니메이션 종료 후 정확한 위치로 고정하고 그룹을 비활성화\n       for(int i = 0; i \u003c bottomUIPanels.Length; i++)\n       {\n            bottomUIPanels[i].anchoredPosition = targetPositions[i];\n       }\n       bottomUIGroup.SetActive(false);\n\n       if (scorePanel != null)\n       {\n           scorePanel.SetActive(false);\n       }\n\n       if (timePanel != null \u0026\u0026 GameModeManager.CurrentMode == GameMode.Infinite)\n       {\n           timePanel.SetActive(false);\n       }\n       \n       isAnimating = false;\n   }\n\n   /// \u003csummary\u003e\n   /// 두 UI 패널을 서로 전환하는 애니메이션 코루틴 (프레임률 독립적으로 수정)\n   /// \u003c/summary\u003e\n   /// \u003cparam name=\"UpPanel\"\u003e위로 올라올 패널\u003c/param\u003e\n   /// \u003cparam name=\"DownPanel\"\u003e아래로 내려갈 패널\u003c/param\u003e\n   private IEnumerator SwitchPanel(RectTransform UpPanel, RectTransform DownPanel)\n   {\n       // UI가 숨겨져 있거나 다른 애니메이션 중이면 전환하지 않음\n       if(!isUIVisible || isAnimating) yield break;\n\n       isSwitching = true; // 전환 애니메이션 시작\n       \n       float elapsedTime = 0f; // 애니메이션 경과 시간 측정용 변수\n\n       // 각 패널의 시작 위치와 목표 위치를 미리 계산\n       Vector2 upStartPos = UpPanel.anchoredPosition;\n       Vector2 downStartPos = DownPanel.anchoredPosition;\n       Vector2 upTargetPos = (UpPanel == TowerPanel) ? towerPanelOriginalPos : skillPanelOriginalPos;\n       Vector2 downTargetPos = (DownPanel == TowerPanel) ? towerPanelOriginalPos + new Vector2(0, hideOffset) \n           : skillPanelOriginalPos + new Vector2(0, hideOffset);\n       \n       SoundManager.Instance.PlaySFX(\"SFX_UI_Switching\");\n       \n       // 경과 시간이 설정한 애니메이션 지속 시간보다 작을 동안 반복\n       while(elapsedTime \u003c animationDuration)\n       {\n           // 매 프레임의 실제 시간만큼 경과 시간을 더해줌\n           elapsedTime += Time.deltaTime;\n           \n           // 애니메이션 진행률 (0.0 ~ 1.0) 계산\n           float progress = Mathf.Clamp01(elapsedTime / animationDuration);\n\n           // 진행률에 따라 시작 위치에서 목표 위치로의 중간 지점을 계산하여 적용\n           UpPanel.anchoredPosition = Vector2.Lerp(upStartPos, upTargetPos, progress);\n           DownPanel.anchoredPosition = Vector2.Lerp(downStartPos, downTargetPos, progress);\n\n           // 다음 프레임까지 대기\n           yield return null; \n       }\n\n       // 애니메이션 종료 후, 정확한 최종 위치로 설정\n       UpPanel.anchoredPosition = upTargetPos;\n       DownPanel.anchoredPosition = downTargetPos;\n       \n       isSwitching = false; // 전환 애니메이션 종료\n   }\n}\n"])</script><script>self.__next_f.push([1,"19:T126c,"])</script><script>self.__next_f.push([1,"using System;\nusing UnityEngine;\n\n/// \u003csummary\u003e\n/// UI 관련 이벤트를 중앙에서 관리하고 다른 스크립트들이 구독할 수 있도록 하는 싱글톤 클래스\n/// \u003c/summary\u003e\npublic class UIEventManager : MonoBehaviour\n{\n    private static UIEventManager instance; // 싱글톤 인스턴스\n    private static bool isQuitting = false; // 애플리케이션 종료 중인지 확인하는 플래그\n    \n    // UI 이벤트 처리를 위한 Action 델리게이트 선언\n    /// \u003csummary\u003e\n    /// 플레이어 HP가 변경될 때 발생하는 이벤트 (현재 HP, 최대 HP)\n    /// \u003c/summary\u003e\n    public Action\u003cfloat, float\u003e OnPlayerHPChanged;\n    /// \u003csummary\u003e\n    /// 플레이어 SP가 변경될 때 발생하는 이벤트 (현재 SP, 최대 SP)\n    /// \u003c/summary\u003e\n    public Action\u003cfloat, float\u003e OnPlayerSPChanged;\n    /// \u003csummary\u003e\n    /// 플레이어 골드가 변경될 때 발생하는 이벤트 (현재 골드)\n    /// \u003c/summary\u003e\n    public Action\u003cint\u003e OnPlayerGoldChanged;\n    /// \u003csummary\u003e\n    /// 플레이어 타워 코스트가 변경될 때 발생하는 이벤트 (현재 타워 코스트, 최대 타워 코스트)\n    /// \u003c/summary\u003e\n    public Action\u003cint\u003e OnTowerCostChanged; // 이 이벤트는 더 이상 사용되지 않음\n    /// \u003csummary\u003e\n    /// 시스템 메시지가 발생할 때 발생하는 이벤트 (메시지 타입)\n    /// \u003c/summary\u003e\n    public Action\u003cSystemType\u003e OnSystemMessage;\n    \n    public static event Action\u003cint\u003e OnRCoinAcquired; // RCoin 획득량 알림 이벤트\n\n    /// \u003csummary\u003e\n    /// UIEventManager의 싱글톤 인스턴스를 반환합니다.\n    /// 애플리케이션 종료 중에는 null을 반환하여 MissingReferenceException을 방지합니다.\n    /// \u003c/summary\u003e\n    public static UIEventManager Instance\n    {\n        get\n        {\n            if (isQuitting) \n            {\n                return null;\n            }\n            if (instance == null)\n            {\n                instance = FindFirstObjectByType\u003cUIEventManager\u003e();\n                if (instance == null)\n                {\n                    Debug.LogError(\"UIEventManager 인스턴스를 찾을 수 없습니다. 씬에 배치되었는지 확인하세요.\");\n                }\n            }\n            return instance;\n        }\n    }\n\n    private void Awake()\n    {\n        isQuitting = false; // 새로운 플레이 세션 시작 시 플래그 초기화\n        // 싱글톤 패턴 구현\n        if (instance == null)\n        {\n            instance = this;\n            DontDestroyOnLoad(gameObject); // 씬이 변경되어도 오브젝트 유지\n        }\n        else\n        {\n            Destroy(gameObject); // 중복 생성 방지\n        }\n    }\n\n    /// \u003csummary\u003e\n    /// 애플리케이션이 종료될 때 호출됩니다.\n    /// 싱글톤 인스턴스 접근 시 MissingReferenceException을 방지하기 위해 플래그를 설정합니다.\n    /// \u003c/summary\u003e\n    private void OnApplicationQuit()\n    {\n        isQuitting = true; \n    }\n\n    /// \u003csummary\u003e\n    /// 플레이어 HP 변경 이벤트를 발생시킵니다.\n    /// \u003c/summary\u003e\n    /// \u003cparam name=\"currentHP\"\u003e현재 HP\u003c/param\u003e\n    /// \u003cparam name=\"maxHP\"\u003e최대 HP\u003c/param\u003e\n    public void UpdatePlayerHP(float currentHP, float maxHP)\n    {\n        OnPlayerHPChanged?.Invoke(currentHP, maxHP);\n    }\n\n    /// \u003csummary\u003e\n    /// 플레이어 SP 변경 이벤트를 발생시킵니다.\n    /// \u003c/summary\u003e\n    /// \u003cparam name=\"currentSP\"\u003e현재 SP\u003c/param\u003e\n    /// \u003cparam name=\"maxSP\"\u003e최대 SP\u003c/param\u003e\n    public void UpdatePlayerSP(float currentSP, float maxSP)\n    {\n        OnPlayerSPChanged?.Invoke(currentSP, maxSP);\n    }\n\n    /// \u003csummary\u003e\n    /// 플레이어 골드 변경 이벤트를 발생시킵니다.\n    /// \u003c/summary\u003e\n    /// \u003cparam name=\"gold\"\u003e현재 골드\u003c/param\u003e\n    public void UpdatePlayerGold(int gold)\n    {\n        OnPlayerGoldChanged?.Invoke(gold);\n    }\n\n    /// \u003csummary\u003e\n    /// 시스템 메시지 이벤트를 발생시킵니다.\n    /// \u003c/summary\u003e\n    /// \u003cparam name=\"type\"\u003e시스템 메시지 타입\u003c/param\u003e\n    public void ShowSystemMessage(SystemType type)\n    {\n        OnSystemMessage?.Invoke(type);\n    }\n\n    /// \u003csummary\u003e\n    /// 플레이어 타워 코스트 변경 이벤트를 발생시킵니다.\n    /// \u003c/summary\u003e\n    /// \u003cparam name=\"currentTowerCost\"\u003e현재 타워 코스트\u003c/param\u003e\n    /// \u003cparam name=\"maxTowerCost\"\u003e최대 타워 코스트\u003c/param\u003e\n    public void UpdateTowerCost(int currentTowerCost)\n    {\n        OnTowerCostChanged?.Invoke(currentTowerCost);\n    }\n    \n    // RCoin 획득 이벤트를 발생시키는 메소드\n    public static void NotifyRCoinAcquired(int amount)\n    {\n        OnRCoinAcquired?.Invoke(amount);\n    }\n}"])</script><script>self.__next_f.push([1,"1a:T1e3d,"])</script><script>self.__next_f.push([1,"using TMPro;\nusing UnityEngine;\nusing System.Collections;\nusing UnityEngine.SceneManagement; // SceneManagement 네임스페이스 추가\n\n/// \u003csummary\u003e\n/// 툴팁 UI를 관리하는 싱글톤 클래스입니다.\n/// \u003c/summary\u003e\npublic class TooltipManager : MonoBehaviour\n{\n    public static TooltipManager Instance { get; private set; }\n\n    [Header(\"UI References\")]\n    [Tooltip(\"툴팁 패널 프리팹\")] \n    [SerializeField] private GameObject tooltipPanelPrefab;\n    private GameObject tooltipPanelInstance; // 인스턴스화된 툴팁 패널 \n    private TextMeshProUGUI headerText;\n    private TextMeshProUGUI contentText;\n    \n    [Tooltip(\"화면 좌우 가장자리와 툴팁 사이의 최소 여유 공간(픽셀)\")]\n    public float horizontalPadding = 10f;\n    \n    [Tooltip(\"마우스 포인터와 툴팁 사이의 수직 간격\")]\n    public float verticalOffset = 10f;\n\n    private void Awake()\n    {\n        if (Instance == null)\n        {\n            Instance = this;\n            DontDestroyOnLoad(gameObject);\n        }\n        else\n        {\n            Destroy(gameObject);\n        }\n    }\n\n    private void OnEnable()\n    {\n        // 씬 로드 이벤트 구독\n        SceneManager.sceneLoaded += OnSceneLoaded; \n        // 현재 씬이 로드된 상태라면 즉시 툴팁 패널을 설정\n        // (Awake/Start보다 OnEnable이 먼저 호출될 수 있으므로)\n        if (gameObject.scene.isLoaded)\n        {\n            OnSceneLoaded(gameObject.scene, LoadSceneMode.Single);\n        }\n    }\n\n    private void OnDisable()\n    {\n        // 씬 로드 이벤트 구독 해제\n        SceneManager.sceneLoaded -= OnSceneLoaded; \n        // 씬이 언로드될 때 현재 툴팁 인스턴스 파괴\n        if (tooltipPanelInstance != null) \n        {\n            Destroy(tooltipPanelInstance);\n            tooltipPanelInstance = null;\n        }\n    }\n\n    private void OnSceneLoaded(Scene scene, LoadSceneMode mode)\n    {\n        // 이전 씬의 툴팁 인스턴스가 남아있다면 파괴\n        if (tooltipPanelInstance != null)\n        {\n            Destroy(tooltipPanelInstance);\n            tooltipPanelInstance = null;\n        }\n\n        // 현재 씬의 Canvas를 찾아서 툴팁 패널을 그 자식으로 인스턴스화\n        Canvas canvas = FindFirstObjectByType\u003cCanvas\u003e();\n        if (canvas == null)\n        {\n            Debug.LogWarning(\"[TooltipManager] No Canvas found in the current scene. Tooltip will not be displayed.\");\n            return;\n        }\n\n        tooltipPanelInstance = Instantiate(tooltipPanelPrefab, canvas.transform); // Canvas의 자식으로 인스턴스화\n        // CanvasGroup 컴포넌트 추가 및 Raycast 비활성화\n        CanvasGroup canvasGroup = tooltipPanelInstance.AddComponent\u003cCanvasGroup\u003e();\n        canvasGroup.blocksRaycasts = false;\n\n        tooltipPanelInstance.GetComponent\u003cRectTransform\u003e().anchoredPosition = Vector2.zero; // 중앙으로 초기화\n        tooltipPanelInstance.name = \"TooltipPanel_RuntimeInstance\"; // 디버깅을 위해 이름 지정\n\n        // 인스턴스화된 툴팁 패널의 자식에서 TextMeshProUGUI 컴포넌트 찾기\n        headerText = tooltipPanelInstance.transform.Find(\"TooltipHeader\").GetComponent\u003cTextMeshProUGUI\u003e();\n        contentText = tooltipPanelInstance.transform.Find(\"TooltipContent\").GetComponent\u003cTextMeshProUGUI\u003e();\n\n        if (headerText == null) Debug.LogError(\"[TooltipManager] headerText not found! Make sure 'TooltipHeader' is a child of tooltipPanelPrefab.\");\n        if (contentText == null) Debug.LogError(\"[TooltipManager] contentText not found! Make sure 'TooltipContent' is a child of tooltipPanelPrefab.\");\n\n        HideTooltip(); // 시작 시 툴팁 숨기기\n    }\n\n    private void Update()\n    {\n        // Update 메서드에서는 툴팁 위치를 지속적으로 업데이트하지 않습니다.\n        // 위치 설정은 ShowTooltip에서 한 번만 이루어집니다.\n    }\n\n    /// \u003csummary\u003e\n    /// 툴팁을 표시하고 내용을 설정합니다。\n    /// \u003c/summary\u003e\n    /// \u003cparam name=\"header\"\u003e툴팁 제목\u003c/param\u003e\n    /// \u003cparam name=\"content\"\u003e툴팁 내용\u003c/param\u003e\n    // [수정 1] 클래스 상단에 패딩 값을 조절할 수 있는 public 변수 추가\n    // 이렇게 하면 유니티 인스펙터 창에서 값을 쉽게 바꿀 수 있습니다.\n    public void ShowTooltip(string header, string content)\n    {\n        if (tooltipPanelInstance == null) return;\n        if (tooltipPanelInstance.activeSelf \u0026\u0026 headerText.text == header \u0026\u0026 contentText.text == content) return;\n\n        StopAllCoroutines();\n        StartCoroutine(ShowTooltipRoutine(header, content));\n    }\n\n    private IEnumerator ShowTooltipRoutine(string header, string content)\n    {\n        // 1. 초기 설정 (이전과 동일)\n        tooltipPanelInstance.SetActive(true);\n        headerText.text = header;\n        contentText.text = content;\n\n        // 2. 캔버스 동적 탐색 및 크기 강제 업데이트 (이전과 동일)\n        Canvas rootCanvas = tooltipPanelInstance.GetComponentInParent\u003cCanvas\u003e();\n        if (rootCanvas == null)\n        {\n            Debug.LogError(\"툴팁이 어떤 Canvas에도 속해있지 않습니다!\");\n            yield break;\n        }\n        Canvas.ForceUpdateCanvases();\n        yield return null;\n\n        // 3. 툴팁의 실제 픽셀 크기 계산 (이전과 동일)\n        RectTransform panelRect = tooltipPanelInstance.GetComponent\u003cRectTransform\u003e();\n        Vector2 panelPixelSize = new Vector2(\n            panelRect.sizeDelta.x * rootCanvas.scaleFactor,\n            panelRect.sizeDelta.y * rootCanvas.scaleFactor\n        );\n\n        Vector2 mousePos = Input.mousePosition;\n        Vector2 desiredPosition;\n\n        // 4. [핵심 로직 변경] 수직 위치 동적 결정\n        // 마우스 커서 아래쪽의 사용 가능한 공간이, 툴팁의 실제 높이 + 약간의 간격보다 작은지 확인합니다.\n        float requiredVerticalSpace = panelPixelSize.y + verticalOffset;\n\n        if (mousePos.y \u003c requiredVerticalSpace)\n        {\n            // 공간이 부족하면 툴팁을 마우스 위로 올립니다.\n            desiredPosition = new Vector2(mousePos.x, mousePos.y + verticalOffset);\n            panelRect.pivot = new Vector2(0.5f, 0f); // Pivot을 하단으로 변경\n        }\n        else\n        {\n            // 공간이 충분하면 기본값인 마우스 아래에 배치합니다.\n            desiredPosition = new Vector2(mousePos.x, mousePos.y - verticalOffset);\n            panelRect.pivot = new Vector2(0.5f, 1f); // Pivot을 상단으로 변경\n        }\n\n        // 5. 수평 위치 결정 (좌우 경계는 고정된 패딩 값 사용)\n        float panelLeftEdge = desiredPosition.x - panelPixelSize.x * panelRect.pivot.x;\n        if (panelLeftEdge \u003c horizontalPadding)\n        {\n            desiredPosition.x = horizontalPadding + panelPixelSize.x * panelRect.pivot.x;\n        }\n\n        float panelRightEdge = desiredPosition.x + panelPixelSize.x * (1 - panelRect.pivot.x);\n        if (panelRightEdge \u003e Screen.width - horizontalPadding)\n        {\n            desiredPosition.x = Screen.width - horizontalPadding - panelPixelSize.x * (1 - panelRect.pivot.x);\n        }\n\n        // 6. 최종 위치 적용\n        panelRect.position = desiredPosition;\n    }\n    \n    /// \u003csummary\u003e\n    /// 툴팁을 숨깁니다.\n    /// \u003c/summary\u003e\n    public void HideTooltip()\n    {\n        StopAllCoroutines();\n        \n        if (tooltipPanelInstance == null) return; // 인스턴스가 없으면 숨기지 않음\n        if (!tooltipPanelInstance.activeSelf) return; // 이미 비활성화되어 있으면 중복 호출 방지\n\n        tooltipPanelInstance.SetActive(false);\n    }\n}"])</script><script>self.__next_f.push([1,"1b:T9a0,"])</script><script>self.__next_f.push([1,"using UnityEngine;\nusing UnityEngine.EventSystems;\n\n/// \u003csummary\u003e\n/// UI 요소에 마우스 오버 시 툴팁을 표시하는 트리거 스크립트입니다.\n/// \u003c/summary\u003e\npublic class TooltipTrigger : MonoBehaviour, IPointerEnterHandler, IPointerExitHandler\n{\n    [Tooltip(\"툴팁에 표시될 제목\")]\n    [SerializeField] private string header;\n    [Tooltip(\"툴팁에 표시될 내용\")]\n    [SerializeField] [TextArea(3, 10)] private string content;\n\n    public System.Func\u003cstring\u003e GetContentCallback; // 툴팁 내용을 동적으로 가져올 콜백 함수\n\n    /// \u003csummary\u003e\n    /// 툴팁의 제목을 설정합니다.\n    /// \u003c/summary\u003e\n    /// \u003cparam name=\"newHeader\"\u003e새로운 제목\u003c/param\u003e\n    public void SetHeader(string newHeader)\n    {\n        header = newHeader;\n    }\n\n    /// \u003csummary\u003e\n    /// 툴팁의 내용을 설정합니다.\n    /// \u003c/summary\u003e\n    /// \u003cparam name=\"newContent\"\u003e새로운 내용\u003c/param\u003e\n    public void SetContent(string newContent)\n    {\n        content = newContent;\n    }\n\n    /// \u003csummary\u003e\n    /// 마우스 포인터가 UI 요소에 진입했을 때 호출됩니다.\n    /// \u003c/summary\u003e\n    /// \u003cparam name=\"eventData\"\u003e이벤트 데이터\u003c/param\u003e\n    public void OnPointerEnter(PointerEventData eventData)\n    {\n        string currentContent = content; // 기본적으로 content 필드 사용\n        if (GetContentCallback != null)\n        {\n            currentContent = GetContentCallback.Invoke(); // 콜백이 할당되어 있으면 콜백 호출\n        }\n\n        // 헤더나 내용이 비어있지 않을 때만 툴팁 표시\n        if (!string.IsNullOrEmpty(header) || !string.IsNullOrEmpty(currentContent))\n        {\n            if (TooltipManager.Instance != null)\n            {\n                TooltipManager.Instance.ShowTooltip(header, currentContent);\n            }\n            else\n            {\n                Debug.LogWarning(\"[TooltipTrigger] TooltipManager.Instance is null.\");\n            }\n        }\n    }\n\n    /// \u003csummary\u003e\n    /// 마우스 포인터가 UI 요소에서 벗어났을 때 호출됩니다.\n    /// \u003c/summary\u003e\n    /// \u003cparam name=\"eventData\"\u003e이벤트 데이터\u003c/param\u003e\n    public void OnPointerExit(PointerEventData eventData)\n    {\n        if (TooltipManager.Instance != null)\n        {\n            TooltipManager.Instance.HideTooltip();\n        }\n        else\n        {\n            Debug.LogWarning(\"[TooltipTrigger] TooltipManager.Instance is null.\");\n        }\n    }\n}\n"])</script><script>self.__next_f.push([1,"1c:T202c,"])</script><script>self.__next_f.push([1,"using System.Collections.Generic;\nusing UnityEngine;\n\n/// \u003csummary\u003e\n/// 타워와 그에 연관된 스킬 정보를 포함하는 ScriptableObject입니다.\n/// \u003c/summary\u003e\n[CreateAssetMenu(fileName = \"NewTowerArchetype\", menuName = \"Tower Defense/Tower Archetype\")]\npublic class TowerArchetype : ScriptableObject\n{\n    [Header(\"General Info\")]\n    public string archetypeID; // 아키타입 고유 ID\n    public string archetypeDisplayName; // UI에 표시될 이름\n    [TextArea(3, 10)]\n    public string archetypeDescription; // 아키타입 전체 설명\n\n    [Header(\"Tower Data\")]\n    [Tooltip(\"타워 아이콘\")]\n    public Sprite towerIcon;\n    [Tooltip(\"이 아키타입에 해당하는 타워 프리팹\")]\n    public GameObject towerPrefab;\n    [Tooltip(\"타워의 무기 관련 스탯\")]\n    public TowerTemplate.Weapon towerWeaponStats; // TowerTemplate의 Weapon 구조체 재사용\n    [Tooltip(\"업그레이드 계수\")]\n    public TowerTemplate.UpgradeCoefficient upgradeCoefficient;\n    [Tooltip(\"타워의 데미지 타입\")]\n    public DamageType towerDamageType; // TowerDefense.Enums.DamageType\n    [Tooltip(\"타워가 다중 공격 타워인지 여부\")]\n    public bool isMultiTargetTower;\n\n    [Header(\"Associated Skill Data\")]\n    [Tooltip(\"스킬 아이콘\")]\n    public Sprite skillIcon;\n    [Tooltip(\"이 타워 아키타입에 연관된 스킬 프리팹\")]\n    public GameObject skillPrefab;\n    [Tooltip(\"스킬 타입 (타워, 액티브, 패시브)\")]\n    public SkillManager.SkillType skillType; // SkillManager의 SkillType 열거형 재사용\n    [Tooltip(\"스킬 지속 시간\")]\n    public float skillDuration;\n    [Tooltip(\"스킬 범위\")]\n    public float skillRange;\n    [Tooltip(\"스킬 사용에 필요한 스킬 포인트\")]\n    public int skillPointCost;\n    [Tooltip(\"스킬 이름\")]\n    public string skillDisplayName;\n    [TextArea(3, 10)]\n    public string skillDescription; // 스킬 설명\n\n    /// \u003csummary\u003e\n    /// 현재 플레이어 스탯을 반영한 타워의 상세 설명을 반환합니다.\n    /// \u003c/summary\u003e\n    public string GetFormattedTowerDescription(PlayerUpgrade playerUpgrade, PlayerData playerData)\n    {\n        // TowerWeapon.cs의 Damage 프로퍼티 계산 로직을 여기에 통합\n        // 기본 데미지\n        float baseDamage = towerWeaponStats.damage;\n        string damageText = $\"데미지 : {Mathf.FloorToInt(baseDamage)}\";\n\n        // 업그레이드 증가 데미지\n        float upgradeDamage = GetUpgradeDamage(towerDamageType, playerUpgrade);\n        if (upgradeDamage \u003e 0)\n        {\n            damageText += $\"(\u003ccolor=red\u003e+{upgradeDamage:F0}\u003c/color\u003e\";\n        }\n\n        // 장비로 증가한 데미지 (TowerWeapon의 Damage 프로퍼티 로직 참고)\n        float currentTowerDamage = (baseDamage + upgradeDamage) * (1 + playerData.attackDamage / 100f);\n        \n        float specificTowerDamageBonus = 0f;\n        // TowerArchetype의 ID나 이름을 기반으로 특정 타워 데미지 보너스 가져오기\n        if (archetypeID.Contains(\"Default\")) specificTowerDamageBonus = playerData.defaultTowerDamage;\n        else if (archetypeID.Contains(\"Arrow\")) specificTowerDamageBonus = playerData.arrowTowerDamage;\n        else if (archetypeID.Contains(\"Laser\")) specificTowerDamageBonus = playerData.laserTowerDamage;\n        else if (archetypeID.Contains(\"Priests\")) specificTowerDamageBonus = playerData.priestsTowerDamage;\n        else if (archetypeID.Contains(\"Spear\")) specificTowerDamageBonus = playerData.spearTowerDamage;\n        else if (archetypeID.Contains(\"Sword\")) specificTowerDamageBonus = playerData.swordTowerDamage;\n\n        currentTowerDamage *= (1 + specificTowerDamageBonus / 100f);\n\n        // 버프 데미지는 현재 TowerWeapon에서 직접 관리되므로, 여기서는 포함하지 않음.\n        // 만약 버프 데미지도 툴팁에 포함하려면 GameManager 등에서 버프 정보를 가져와야 함.\n\n        float equipmentDamageBonus = currentTowerDamage - (baseDamage + upgradeDamage); // 순수 장비로 인한 증가량\n\n        if (equipmentDamageBonus \u003e 0)\n        {\n            if (upgradeDamage \u003c= 0) damageText += \" (\"; // 업그레이드 데미지가 없으면 괄호 시작\n            damageText += \"\u003ccolor=green\u003e+\" + Mathf.FloorToInt(equipmentDamageBonus) + \"\u003c/color\u003e\";\n        }\n\n        // 버프 데미지는 현재 TowerWeapon에서 직접 관리되므로, 여기서는 포함하지 않음.\n        // 툴팁에 포함하려면 GameManager 등에서 버프 정보를 가져와야 함.\n        // if (currentTower.BuffDamage \u003e 0) { ... }\n\n        // 괄호 닫기\n        if (upgradeDamage \u003e 0 || equipmentDamageBonus \u003e 0)\n        {\n            damageText += \")\";\n        }\n\n        string content = damageText + \"\\n\";\n        if (towerWeaponStats.attackSpeed == 0f)\n        {\n            content += $\"공격 속도: 지속\\n\";\n        }\n        else\n        {\n            content += $\"공격 속도: {towerWeaponStats.attackSpeed * (1 + playerData.attackSpeed / 100f):F1}\\n\";\n        }\n        \n        content += $\"공격 범위: {towerWeaponStats.range * (1 + playerData.attackRange / 100f):F1}\\n\";\n        content += $\"타입: {GetDamageTypeString(towerDamageType)}\";\n        content += $\"\\n{archetypeDescription}\"; // 아키타입 전체 설명\n\n        return content;\n    }\n\n    /// \u003csummary\u003e\n    /// 현재 플레이어 스탯을 반영한 스킬의 상세 설명을 반환합니다.\n    /// \u003c/summary\u003e\n    public string GetFormattedSkillDescription(PlayerUpgrade playerUpgrade, PlayerData playerData)\n    {\n        // string content = $\"스킬 포인트 소모: {skillPointCost}\\n\";\n        string content = $\"지속 시간: {skillDuration:F1}초\\n\";\n\n        if (skillRange == 0)\n        {\n            content += $\"범위: (적 존재 시)즉시 발동\\n\";\n        }\n        else\n        {\n            content += $\"범위: {skillRange:F1}\\n\";\n        }\n        content += $\"\\n{skillDescription}\";\n\n        // 스킬 데미지 등 플레이어 스탯에 영향을 받는 부분이 있다면 여기에 추가\n        // 예: 스킬 데미지: {baseSkillDamage * (1 + playerData.skillDamage / 100f)}\n\n        return content;\n    }\n\n    // DamageType을 문자열로 변환하는 헬퍼 함수 (TowerWeapon.cs에서 복사)\n    private string GetDamageTypeString(DamageType type)\n    {\n        switch (type)\n        {\n            case DamageType.PhysicalType: return \"물리\";\n            case DamageType.MagicalType: return \"마법\";\n            case DamageType.HybridType: return \"복합\";\n            default: return \"알 수 없음\";\n        }\n    }\n\n    private float GetUpgradeDamage(DamageType damageType, PlayerUpgrade playerUpgrade)\n    {\n        float addedDamage = 0f;\n        var coefficient = upgradeCoefficient;\n\n        switch (damageType)\n        {\n            case DamageType.PhysicalType:\n                // 제곱 성장(damageQuadratic) 공식을 추가합니다.\n                addedDamage = (coefficient.damage * playerUpgrade.PhysicUpgrade) +\n                              (coefficient.damageQuadratic * playerUpgrade.PhysicUpgrade * playerUpgrade.PhysicUpgrade);\n                break;\n\n            case DamageType.MagicalType:\n                // 제곱 성장(damageQuadratic) 공식을 추가합니다.\n                addedDamage = (coefficient.damage * playerUpgrade.MagicUpgrade) +\n                              (coefficient.damageQuadratic * playerUpgrade.MagicUpgrade * playerUpgrade.MagicUpgrade);\n                break;\n\n            case DamageType.HybridType:\n                // 하이브리드 타입에도 제곱 성장 공식을 적용합니다.\n                float totalPhysicDmg = (coefficient.damage * playerUpgrade.PhysicUpgrade) +\n                                       (coefficient.damageQuadratic * playerUpgrade.PhysicUpgrade * playerUpgrade.PhysicUpgrade);\n                float totalMagicDmg = (coefficient.damage * playerUpgrade.MagicUpgrade) +\n                                      (coefficient.damageQuadratic * playerUpgrade.MagicUpgrade * playerUpgrade.MagicUpgrade);\n\n                addedDamage = (totalPhysicDmg + totalMagicDmg) * 0.6f;\n                break;\n        }\n        return addedDamage;\n    }\n}"])</script><script>self.__next_f.push([1,"1d:T17fc,"])</script><script>self.__next_f.push([1,"using System.Collections;\nusing UnityEngine;\n\npublic enum EnemyDestroyType { Kill = 0, Arrive }\npublic class Enemy : MonoBehaviour\n{\n    public EnemyType enemyType; // 적의 종류를 나타내는 필드 추가\n\n    private int wayPointCount; // 이동 경로 개수\n    private Transform[] wayPoints; // 이동 경로 정보\n    private int currentIndex = 0; // 현재 목표지점 인덱스\n    private EnemySpawner enemySpawner; // 적의 삭제를 본인이 하지 않고 EnemySpawner에서 제어\n    private SpriteRenderer spriteRenderer;\n\n    public SliderPositionAutoSetter HpSlider { get; set; } // 추가: HP 슬라이더 참조\n\n    public float moveSpeed;\n    private float baseMoveSpeed;  // 추가\n\n    private int _gold; // Private backing field for gold\n    public int Gold // Public property for gold\n    {\n        get { return _gold; }\n        private set { _gold = value; } // Make setter private to control modification\n    }\n    \n    public void Setup(EnemySpawner enemySpawer, Transform[] wayPoints, int waveIndex, EnemyType type) // Add EnemyType parameter\n    {\n        spriteRenderer = GetComponent\u003cSpriteRenderer\u003e();\n        baseMoveSpeed = moveSpeed;  // 추가: 초기 속도 저장\n        \n        // '위험 수당' 특성의 이동 속도 증가를 적용합니다.\n        if (PerkManager.Instance != null)\n        {\n            moveSpeed *= PerkManager.Instance.perk_enemySpeedModifier;\n        }\n        \n        this.enemySpawner = enemySpawer;\n        this.enemyType = type; // EnemyType 설정\n\n        // 적 이동 경로 WayPoints 정보 생성\n        wayPointCount = wayPoints.Length;\n        this.wayPoints = new Transform[wayPointCount];\n        this.wayPoints = wayPoints;\n\n        // 적이 위치를 첫번째 wayPoint 위치로 설정\n        transform.position = wayPoints[currentIndex].position;\n\n        setWaveGoldValue(waveIndex); // Call the new method here\n\n        // 적 이동/목표지점 설정 코루틴 함수 시작\n        NextMoveTo();\n    }\n    \n    public void setWaveGoldValue(int index)\n    {\n        // Base gold amount\n        int calculatedGold = 10; // Starting gold\n\n        // Linear increase\n        calculatedGold += (5 * index); // 5 gold per wave\n\n        // Threshold for increased scaling (e.g., after wave 20)\n        int thresholdWave = 20;\n        if (index \u003e= thresholdWave)\n        {\n            int effectiveIndex = index - thresholdWave + 1;\n            calculatedGold += (10 * effectiveIndex * effectiveIndex); // Additional quadratic increase\n        }\n\n        Gold = calculatedGold;\n        \n        // '위험 수당' 특성의 골드 획득량 증가를 적용합니다.\n        if (PerkManager.Instance != null)\n        {\n            Gold = (int)(calculatedGold * PerkManager.Instance.perk_goldModifier);\n        }\n        else\n        {\n            Gold = calculatedGold; // PerkManager가 없을 경우 대비\n        }\n    }\n    \n    // 추가: 속도 리셋 메서드\n    public void ResetMoveSpeed() \n    {\n        moveSpeed = baseMoveSpeed;\n    }\n\n    private void NextMoveTo()\n    {\n        // 아직 이동할 wayPoints가 남아있다면\n        if (currentIndex \u003c wayPointCount - 1)\n        {\n            // 적의 위치를 정확하게 목표 위치로 설정\n            transform.position = wayPoints[currentIndex].position;\n            // 이동 방향 설정 =\u003e 다음 목표지점(wayPoints)\n            currentIndex++;\n\n            if (spriteRenderer != null)\n            {\n                Vector3 nextPosition = wayPoints[currentIndex].position;\n                if (nextPosition.x \u003e transform.position.x)\n                {\n                    // 다음 목적지가 오른쪽에 있으면 flipX = false (오른쪽을 봄)\n                    spriteRenderer.flipX = false;\n                }\n                else if (nextPosition.x \u003c transform.position.x)\n                {\n                    // 다음 목적지가 왼쪽에 있으면 flipX = true (왼쪽을 봄)\n                    spriteRenderer.flipX = true;\n                }\n                // x축 이동이 없으면 (수직 이동) 현재 방향을 유지합니다.\n            }\n            \n            StartCoroutine(MoveTo());\n        }\n        // 현재 위치가 마지막 wayPoints이면\n        else \n        {\n            // 무한 모드인지 확인\n            if (GameModeManager.CurrentMode == GameMode.Infinite)\n            {\n                // 적 재순환: 위치와 인덱스를 처음으로 되돌립니다.\n                transform.position = wayPoints[0].position;\n                currentIndex = 0;\n                // 다시 이동을 시작합니다.\n                NextMoveTo();\n            }\n            else\n            {\n                // [기존 로직] 일반 모드일 경우\n                Gold = 0;\n                OnDie(EnemyDestroyType.Arrive);\n            }\n        }\n    }\n\n    public void OnDie(EnemyDestroyType type)\n    {\n        // 무한 모드이고, 적이 '처치'되었을 경우 '무한 모드 전용 점수'를 추가합니다.\n        if (GameModeManager.CurrentMode == GameMode.Infinite \u0026\u0026 type == EnemyDestroyType.Kill)\n        {\n            // GameManager에 적 처치 점수를 추가해달라고 요청합니다.\n            // (점수 공식: 적 골드 * 맵 난이도 배율)\n            GameManager.Instance.AddScore_Infinite_Kill(this.Gold);\n        }\n\n        // EnemySpawner에 죽음을 알리는 것은 모든 모드에서 동일하게 실행됩니다.\n        enemySpawner.DestroyEnemy(type, this, Gold);\n    }\n\n    private IEnumerator MoveTo()\n    {\n        float distance = 1f;\n\n        while (distance \u003e 0.04f)\n        {\n            distance = Vector3.Distance(transform.position, wayPoints[currentIndex].position);\n\n            if(distance \u003c 0.04f)\n            {\n                transform.position = wayPoints[currentIndex].position;\n                NextMoveTo();\n                yield break;\n            }\n\n            transform.position = Vector3.MoveTowards(transform.position, wayPoints[currentIndex].position, Time.deltaTime * moveSpeed);\n\n            yield return null;\n        }\n    }\n}"])</script><script>self.__next_f.push([1,"1e:T79e,"])</script><script>self.__next_f.push([1,"using System.Collections.Generic;\nusing UnityEngine;\n\n// 오브젝트 풀링 시스템\n// 게임 오브젝트의 생성과 파괴를 최소화하여 성능을 최적화\npublic class ObjectPool\u003cT\u003e where T : UnityEngine.Object\n{\n    private readonly Stack\u003cT\u003e _pool = new Stack\u003cT\u003e();\n    private readonly T _prefab;\n    private readonly Transform _parent;\n\n    public ObjectPool(T prefab, int initialSize, Transform parent = null)\n    {\n        _prefab = prefab;\n        _parent = parent;\n\n        for (int i = 0; i \u003c initialSize; i++)\n        {\n            T obj = Object.Instantiate(prefab, parent);\n            // T가 GameObject 또는 Component일 경우에만 SetActive 호출\n            if (obj is GameObject go) go.SetActive(false);\n            else if (obj is Component comp) comp.gameObject.SetActive(false);\n            _pool.Push(obj);\n        }\n    }\n\n    public T Get()\n    {\n        T obj;\n        while (_pool.Count \u003e 0)\n        {\n            obj = _pool.Pop();\n            if (obj) // 유효성 검사\n            {\n                // T가 GameObject 또는 Component일 경우에만 SetActive 호출\n                if (obj is GameObject go1) go1.SetActive(true);\n                else if (obj is Component comp1) comp1.gameObject.SetActive(true);\n                return obj;\n            }\n        }\n        obj = Object.Instantiate(_prefab, _parent);\n        // T가 GameObject 또는 Component일 경우에만 SetActive 호출\n        if (obj is GameObject go2) go2.SetActive(true);\n        else if (obj is Component comp2) comp2.gameObject.SetActive(true);\n        return obj;\n    }\n\n    public void Return(T obj)\n    {\n        if (obj) // 유효성 검사\n        {\n            // T가 GameObject 또는 Component일 경우에만 SetActive 호출\n            if (obj is GameObject go) go.SetActive(false);\n            else if (obj is Component comp) comp.gameObject.SetActive(false);\n            _pool.Push(obj);\n        }\n    }\n}\n"])</script><script>self.__next_f.push([1,"1f:T2027,"])</script><script>self.__next_f.push([1,"using System.Collections.Generic;\nusing UnityEngine;\n\n/// \u003csummary\u003e\n/// 맵의 랜덤 경로를 생성하는 클래스\n/// \u003c/summary\u003e\npublic class RandomPathGenerator : MonoBehaviour \n{\n    [Header(\"Path Generation Settings\")]\n    [SerializeField] [Tooltip(\"경로 세그먼트의 최소 개수\")]\n    private int minSegments = 4;\n    [SerializeField] [Tooltip(\"경로 세그먼트의 최대 개수\")]\n    private int maxSegments = 8;\n   \n    \n\n    private int _segmentCount; // 실제로 사용된 세그먼트 수\n    public int SegmentCount =\u003e _segmentCount; // 외부 접근용 프로퍼티\n\n    // 맵의 시작점과 끝점 정의\n    private readonly Vector2Int LEFT_POINT = new Vector2Int(-(GameConstants.MAP_WIDTH/2) + 1, 4);\n    private readonly Vector2Int RIGHT_POINT = new Vector2Int((GameConstants.MAP_WIDTH/2) - 2, 4);\n\n    private Vector2Int START_POINT; // 실제 경로 시작점\n    private Vector2Int END_POINT;   // 실제 경로 끝점\n    private bool isLeftToRight;     // 경로가 왼쪽에서 오른쪽으로 진행하는지 여부\n\n    // 경로 방향 확인용 프로퍼티\n    public bool IsLeftToRight =\u003e isLeftToRight;\n\n    /// \u003csummary\u003e\n    /// 랜덤 웨이포인트 경로를 생성하고 난이도를 계산합니다.\n    /// \u003c/summary\u003e\n    /// \u003creturns\u003e생성된 웨이포인트 배열\u003c/returns\u003e\n    public Vector2Int[] GenerateWaypoints()\n    {\n        // 시작 방향을 랜덤하게 결정 (왼쪽에서 오른쪽 또는 오른쪽에서 왼쪽)\n        isLeftToRight = Random.value \u003e 0.5f;\n        START_POINT = isLeftToRight ? LEFT_POINT : RIGHT_POINT;\n        END_POINT = isLeftToRight ? RIGHT_POINT : LEFT_POINT;\n    \n        Vector2Int[] path;\n        int attempts = 0;\n        const int MAX_ATTEMPTS = 100; // 최대 경로 생성 시도 횟수\n        int currentMaxSegments = maxSegments; // 현재 시도에서 사용할 최대 세그먼트 수\n        int usedSegments = 0;  // 실제로 사용된 세그먼트 수\n\n        // 유효한 경로가 생성될 때까지 반복 시도\n        do\n        {\n            path = GeneratePath(currentMaxSegments, out usedSegments);\n            attempts++;\n\n            // 일정 횟수 이상 실패 시 세그먼트 수를 줄여서 재시도\n            if (attempts % 20 == 0 \u0026\u0026 currentMaxSegments \u003e minSegments)\n            {\n                currentMaxSegments--;\n            }\n\n            // 최대 시도 횟수를 초과하면 단순 경로로 대체\n            if(attempts \u003e= MAX_ATTEMPTS)\n            {\n                return GenerateSimplePath();\n            }\n        } \n        while (!ValidateWaypoints(path)); // 생성된 경로가 유효한지 검증\n\n        _segmentCount = usedSegments; // 사용된 세그먼트 수 저장\n    \n        return path;\n    }\n\n    /// \u003csummary\u003e\n    /// 경로 생성에 실패했을 때 대체로 사용되는 단순 경로를 생성합니다.\n    /// \u003c/summary\u003e\n    /// \u003creturns\u003e단순 웨이포인트 배열\u003c/returns\u003e\n    private Vector2Int[] GenerateSimplePath()\n    {\n        List\u003cVector2Int\u003e waypoints = new List\u003cVector2Int\u003e();\n        \n        // 시작점에서 중간 높이로 이동 후 끝점으로 이어지는 단순 경로\n        waypoints.Add(START_POINT);\n        waypoints.Add(new Vector2Int(START_POINT.x, 0));\n        waypoints.Add(new Vector2Int(END_POINT.x, 0));\n        waypoints.Add(END_POINT);\n        \n        return waypoints.ToArray();\n    }\n    \n    /// \u003csummary\u003e\n    /// 실제 랜덤 경로를 생성하는 핵심 메소드\n    /// \u003c/summary\u003e\n    /// \u003cparam name=\"currentMaxSegments\"\u003e현재 시도에서 사용할 최대 세그먼트 수\u003c/param\u003e\n    /// \u003cparam name=\"usedSegments\"\u003e실제로 사용된 세그먼트 수 (out 파라미터)\u003c/param\u003e\n    /// \u003creturns\u003e생성된 웨이포인트 배열\u003c/returns\u003e\n    private Vector2Int[] GeneratePath(int currentMaxSegments, out int usedSegments)\n    {\n        List\u003cVector2Int\u003e waypoints = new List\u003cVector2Int\u003e();\n        waypoints.Add(START_POINT);\n\n        // 첫 번째 수직 이동 지점 결정\n        int firstVerticalDepth = Random.Range(-(GameConstants.MAP_HEIGHT/2), START_POINT.y - 1);\n        waypoints.Add(new Vector2Int(START_POINT.x, firstVerticalDepth));\n\n        int currentX = START_POINT.x;\n        int currentY = firstVerticalDepth;\n\n        // 남은 X축 이동 거리를 기반으로 실제 사용할 세그먼트 수 결정\n        int remainingX = Mathf.Abs(END_POINT.x - currentX);\n        usedSegments = Mathf.Min(currentMaxSegments, Mathf.Max(minSegments, remainingX));\n\n        for (int i = 0; i \u003c usedSegments; i++)\n        {\n            // X 이동 거리 계산 (남은 세그먼트 수와 남은 X 거리를 고려)\n            int remainingSegments = usedSegments - i;\n            int minStep = Mathf.Max(1, remainingX / remainingSegments);\n            int maxStep = Mathf.Min(2, remainingX);\n            int xStep = Random.Range(minStep, maxStep + 1);\n\n            // 경로 방향에 따라 X 좌표 업데이트\n            if(isLeftToRight)\n                currentX = Mathf.Min(currentX + xStep, END_POINT.x - 1);\n            else\n                currentX = Mathf.Max(currentX - xStep, END_POINT.x + 1);\n\n            remainingX = Mathf.Abs(END_POINT.x - currentX);\n\n            // Y 위치 결정 (맵 경계 및 다음 세그먼트 고려)\n            int minY = -(GameConstants.MAP_HEIGHT/2);\n            int maxY = (i == usedSegments - 1) ? END_POINT.y - 1 : (GameConstants.MAP_HEIGHT/2) - 1;\n\n            int newY;\n            int attempts = 0;\n            // 유효한 Y 위치를 찾을 때까지 반복 시도\n            do \n            {\n                newY = Random.Range(minY, maxY + 1);\n                attempts++;\n\n                // 특정 시도 횟수 이상 실패 시, 현재 Y에서 1칸 이동 시도\n                if(attempts \u003e 5)\n                {\n                    newY = currentY + (Random.value \u003e 0.5f ? 1 : -1);\n                    newY = Mathf.Clamp(newY, minY, maxY); // 맵 경계 내로 클램프\n                    break;\n                }\n            } \n            while (Mathf.Abs(newY - currentY) \u003c 1); // 현재 Y와 최소 1칸 이상 차이나도록\n\n            // 현재 X 좌표와 이전 Y 좌표로 웨이포인트 추가\n            waypoints.Add(new Vector2Int(currentX, currentY));\n\n            // 마지막 세그먼트가 아니면 새로운 Y 좌표로 웨이포인트 추가\n            if (i \u003c usedSegments - 1)\n            {\n                waypoints.Add(new Vector2Int(currentX, newY));\n                currentY = newY;\n            }\n        }\n\n        // 최종 끝점 추가\n        waypoints.Add(new Vector2Int(END_POINT.x, currentY));\n        waypoints.Add(END_POINT);\n\n        return waypoints.ToArray();\n    }\n   \n    /// \u003csummary\u003e\n    /// 생성된 웨이포인트 경로의 유효성을 검사합니다.\n    /// \u003c/summary\u003e\n    /// \u003cparam name=\"waypoints\"\u003e검사할 웨이포인트 배열\u003c/param\u003e\n    /// \u003creturns\u003e경로가 유효하면 true, 그렇지 않으면 false\u003c/returns\u003e\n    private bool ValidateWaypoints(Vector2Int[] waypoints)\n    {\n        // 1. 최소 웨이포인트 개수 체크\n        if (waypoints.Length \u003c 3)\n        {\n            return false;\n        }\n           \n        // 2. 시작점과 끝점 일치 여부 검사\n        if (waypoints[0] != START_POINT || waypoints[waypoints.Length - 1] != END_POINT)\n        {\n            return false;\n        }\n           \n        // 3. 모든 웨이포인트가 맵 경계 내에 있는지 검사\n        for (int i = 0; i \u003c waypoints.Length; i++)\n        {\n            if (waypoints[i].x \u003c -(GameConstants.MAP_WIDTH/2) || waypoints[i].x \u003e (GameConstants.MAP_WIDTH/2) - 1 ||\n                waypoints[i].y \u003c -(GameConstants.MAP_HEIGHT/2) || waypoints[i].y \u003e (GameConstants.MAP_HEIGHT/2) - 1)\n            {\n                return false;\n            }\n        }\n       \n        // 4. 연속된 웨이포인트 간의 최소 거리 검사 (너무 가까운 포인트 방지)\n        for (int i = 1; i \u003c waypoints.Length; i++)\n        {\n            float distance = Vector2.Distance(waypoints[i], waypoints[i-1]);\n            if (distance \u003c 1)\n            {\n                return false;\n            }\n        }\n       \n        return true;\n    }\n}"])</script><script>self.__next_f.push([1,"20:T2e28,"])</script><script>self.__next_f.push([1,"using UnityEngine;\nusing UnityEngine.Tilemaps;\nusing System.Collections.Generic; // List를 사용하기 위해 추가\n\n// [추가] 타일셋을 관리하기 위한 새로운 구조체를 정의합니다.\n[System.Serializable]\npublic struct TileSet\n{\n    public string name; // 타일셋의 이름\n    private string bgmClipName; // 이 타일셋(맵)에서 재생할 BGM 오디오 클립의 이름\n    public string BgmClipName { get; private set; }\n    \n    [Header(\"Path Tiles\")]\n    public TileBase horizontalPathTile;    // 가로 길\n    public TileBase verticalPathTile;      // 세로 길\n    public TileBase cornerTopRightTile;    // ┗ \n    public TileBase cornerTopLeftTile;     // ┛\n    public TileBase cornerBottomRightTile; // ┏\n    public TileBase cornerBottomLeftTile;  // ┓\n    \n    [Header(\"Building Tiles\")]\n    public TileBase startCastleTile; // 시작 성 타일\n    public TileBase endCastleTile;   // 도착 성 타일\n    \n    [Header(\"Wall Sprites\")]\n    public Sprite baseWallSprite; // 기본 벽 (단일)\n    public Sprite[] decorativeWallSprites; // 장식 벽 (배열)\n    \n    // 구조체의 필드 값을 초기화하고 BGM 이름을 생성\n    public void Initialize()\n    {\n        // 이름 필드가 비어있지 않다면, \"BGM_\" 접두사와 이름을 조합하여 BGM 클립 이름을 만듭니다.\n        if (!string.IsNullOrEmpty(name))\n        {\n            BgmClipName = \"BGM_Game_\" + name;\n        }\n        else\n        {\n            BgmClipName = string.Empty;\n        }\n    }\n}\n\n/// \u003csummary\u003e\n/// 랜덤 경로 데이터를 기반으로 타일맵에 맵을 생성하는 클래스\n/// \u003c/summary\u003e\npublic class MapGenerator : MonoBehaviour\n{\n    [Header(\"Tilemap References\")]\n    [SerializeField] private Transform groundParent;   // 타일 벽(장애물)이 생성될 부모 Transform\n    [SerializeField] private Tilemap pathTilemap;      // 경로 타일맵\n    [SerializeField] private Tilemap buildingTilemap;  // 건물(성) 타일맵\n\n    [Header(\"Prefab References\")]\n    [SerializeField] private GameObject tileWallPrefab; // 타일 벽 프리팹\n    \n    [Header(\"Tile Sets\")]\n    [SerializeField] private TileSet[] tileSets; // 사용할 모든 타일셋 테마 배열\n    \n    [Range(0, 1)]\n    [SerializeField] private float decorativeTileChance = 0.05f; // 장식 타일이 나타날 확률 (5%)\n    \n    private TileSet selectedTileSet; // 이번 게임에서 선택된 타일셋\n    \n    // 맵의 경계를 정의하는 상수\n    private readonly int startX = -(GameConstants.MAP_WIDTH / 2);\n    private readonly int endX = (GameConstants.MAP_WIDTH / 2) - 1;\n    private readonly int startY = -(GameConstants.MAP_HEIGHT / 2);\n    private readonly int endY = (GameConstants.MAP_HEIGHT / 2) - 1;\n    \n    /// \u003csummary\u003e\n    /// 맵 생성을 시작하는 메인 메소드\n    /// \u003c/summary\u003e\n    /// \u003cparam name=\"waypoints\"\u003e생성할 경로의 웨이포인트 배열\u003c/param\u003e\n    /// \u003cparam name=\"isLeftToRight\"\u003e경로의 방향 (왼쪽에서 오른쪽으로)\u003c/param\u003e\n    public void GenerateMap(Vector2Int[] waypoints, bool isLeftToRight)\n    {\n        if (tileSets == null || tileSets.Length == 0)\n        {\n            Debug.LogError(\"MapGenerator에 타일셋이 설정되지 않았습니다!\");\n            return;\n        }\n\n        // 게임 시작 시 사용할 타일셋을 무작위로 하나 선택하여 저장합니다.\n        if (PlayerPrefs.GetInt(\"TutorialCompleted\", 0) == 0)\n        {\n            // 튜토리얼 중에는 항상 첫 번째 타일셋을 사용합니다.\n            selectedTileSet = tileSets[0];\n        }\n        else\n        {\n            // 1. 현재 게임 난이도를 가져옵니다.\n            int difficultyLevel = DifficultyManager.Instance.CurrentDifficultyLevel;\n\n            // 2. 난이도에 따라 잠금 해제된 맵의 개수를 결정합니다.\n            int unlockedMapCount;\n            if (difficultyLevel \u003c 25)\n            {\n                unlockedMapCount = 1;\n            }\n            else if (difficultyLevel \u003c 50)\n            {\n                unlockedMapCount = 2;\n            }\n            else if (difficultyLevel \u003c 75)\n            {\n                unlockedMapCount = 3;\n            }\n            else // 75 이상\n            {\n                unlockedMapCount = 4;\n            }\n\n            // 3. (안전 장치) 실제 설정된 타일셋 배열의 크기를 넘지 않도록 합니다.\n            // 예를 들어, 타일셋을 3개만 설정했다면 4개가 선택되는 오류를 방지합니다.\n            unlockedMapCount = Mathf.Min(unlockedMapCount, tileSets.Length);\n\n            // 4. 잠금 해제된 맵 중에서만 무작위로 하나를 선택합니다.\n            int randomIndex = Random.Range(0, unlockedMapCount);\n            selectedTileSet = tileSets[randomIndex];\n        }\n        \n        selectedTileSet.Initialize();\n        \n        if (SoundManager.Instance != null \u0026\u0026 !string.IsNullOrEmpty(selectedTileSet.BgmClipName))\n        {\n            SoundManager.Instance.PlayBGM(selectedTileSet.BgmClipName, true);\n        }\n\n        ClearAllTilemaps();\n        ClearTileWalls();\n        PlacePathTiles(waypoints); // 직선 및 코너 경로 타일 배치\n        PlaceCastles(waypoints[0], waypoints[waypoints.Length - 1]);\n        FillWithTileWalls();\n    }\n\n    /// \u003csummary\u003e\n    /// 모든 타일맵을 초기화합니다.\n    /// \u003c/summary\u003e\n    private void ClearAllTilemaps()\n    {\n        pathTilemap.ClearAllTiles();\n        buildingTilemap.ClearAllTiles();\n    }\n\n    /// \u003csummary\u003e\n    /// 기존에 생성된 타일 벽을 모두 제거합니다.\n    /// \u003c/summary\u003e\n    private void ClearTileWalls()\n    {\n        foreach (Transform child in groundParent)\n        {\n            Destroy(child.gameObject);\n        }\n    }\n\n    /// \u003csummary\u003e\n    /// 웨이포인트를 따라 직선 및 코너 경로 타일을 배치합니다.\n    /// \u003c/summary\u003e\n    /// \u003cparam name=\"waypoints\"\u003e경로 웨이포인트 배열\u003c/param\u003e\n    private void PlacePathTiles(Vector2Int[] waypoints)\n    {\n        // 1. Fill straight paths first\n        for (int i = 0; i \u003c waypoints.Length - 1; i++)\n        {\n            Vector2Int currentPoint = waypoints[i];\n            Vector2Int nextPoint = waypoints[i + 1];\n\n            if (currentPoint.x == nextPoint.x) // Vertical\n            {\n                int startY = Mathf.Min(currentPoint.y, nextPoint.y);\n                int endY = Mathf.Max(currentPoint.y, nextPoint.y);\n                for (int y = startY; y \u003c= endY; y++)\n                {\n                    pathTilemap.SetTile(new Vector3Int(currentPoint.x, y, 0), selectedTileSet.verticalPathTile);\n                }\n            }\n            else if (currentPoint.y == nextPoint.y) // Horizontal\n            {\n                int startX = Mathf.Min(currentPoint.x, nextPoint.x);\n                int endX = Mathf.Max(currentPoint.x, nextPoint.x);\n                for (int x = startX; x \u003c= endX; x++)\n                {\n                    pathTilemap.SetTile(new Vector3Int(x, currentPoint.y, 0), selectedTileSet.horizontalPathTile);\n                }\n            }\n        }\n\n        // 2. Place corner tiles, overwriting the straight tiles at the corner point\n        for (int i = 1; i \u003c waypoints.Length - 1; i++)\n        {\n            Vector2Int previousPoint = waypoints[i - 1];\n            Vector2Int currentPoint = waypoints[i];\n            Vector2Int nextPoint = waypoints[i + 1];\n\n            Vector2Int dirTo = currentPoint - previousPoint;\n            Vector2Int dirFrom = nextPoint - currentPoint;\n\n            TileBase cornerTile = null;\n\n            // ┏ (cornerBottomRightTile): Below -\u003e Right or Right -\u003e Below\n            if ((dirTo.y \u003e 0 \u0026\u0026 dirFrom.x \u003e 0) || (dirTo.x \u003c 0 \u0026\u0026 dirFrom.y \u003c 0))\n            {\n                cornerTile = selectedTileSet.cornerBottomRightTile;\n            }\n            // ┓ (cornerBottomLeftTile): Below -\u003e Left or Left -\u003e Below\n            else if ((dirTo.y \u003e 0 \u0026\u0026 dirFrom.x \u003c 0) || (dirTo.x \u003e 0 \u0026\u0026 dirFrom.y \u003c 0))\n            {\n                cornerTile = selectedTileSet.cornerBottomLeftTile;\n            }\n            // ┗ (cornerTopRightTile): Above -\u003e Right or Right -\u003e Above\n            else if ((dirTo.y \u003c 0 \u0026\u0026 dirFrom.x \u003e 0) || (dirTo.x \u003c 0 \u0026\u0026 dirFrom.y \u003e 0))\n            {\n                cornerTile = selectedTileSet.cornerTopRightTile;\n            }\n            // ┛ (cornerTopLeftTile): Above -\u003e Left or Left -\u003e Above\n            else if ((dirTo.y \u003c 0 \u0026\u0026 dirFrom.x \u003c 0) || (dirTo.x \u003e 0 \u0026\u0026 dirFrom.y \u003e 0))\n            {\n                cornerTile = selectedTileSet.cornerTopLeftTile;\n            }\n\n            if (cornerTile != null)\n            {\n                pathTilemap.SetTile(new Vector3Int(currentPoint.x, currentPoint.y, 0), cornerTile);\n            }\n        }\n    }\n    \n    /// \u003csummary\u003e\n    /// 시작점과 도착점에 성 타일을 배치합니다.\n    /// \u003c/summary\u003e\n    private void PlaceCastles(Vector2Int start, Vector2Int end)\n    {\n        Vector3Int startCell = new Vector3Int(start.x, start.y, 0);\n        Vector3Int endCell = new Vector3Int(end.x, end.y, 0);\n        \n        buildingTilemap.SetTile(new Vector3Int(start.x, start.y, 0), selectedTileSet.startCastleTile);\n        buildingTilemap.SetTile(new Vector3Int(end.x, end.y, 0), selectedTileSet.endCastleTile);\n        \n        // [추가] 타일의 월드 좌표를 GameManager에 저장합니다.\n        if (GameManager.Instance != null)\n        {\n            GameManager.Instance.startCastlePosition = buildingTilemap.GetCellCenterWorld(startCell);\n            GameManager.Instance.endCastlePosition = buildingTilemap.GetCellCenterWorld(endCell);\n        }\n    }\n\n    /// \u003csummary\u003e\n    /// 경로가 아닌 모든 공간을 타일 벽으로 채웁니다.\n    /// \u003c/summary\u003e\n    private void FillWithTileWalls()\n    {\n        int border = 2;\n        \n        for (int x = startX-border; x \u003c= endX+border; x++)\n        {\n            for (int y = startY-border; y \u003c= endY+border; y++)\n            {\n                Vector3Int cellPosition = new Vector3Int(x, y, 0);\n                if (!pathTilemap.HasTile(cellPosition) \u0026\u0026 !buildingTilemap.HasTile(cellPosition))\n                {\n                    Vector3 position = new Vector3(x + 0.5f, y + 0.5f, 0);\n                    GameObject tileWall = Instantiate(tileWallPrefab, position, Quaternion.identity, groundParent);\n                \n                    SpriteRenderer sr = tileWall.GetComponent\u003cSpriteRenderer\u003e();\n                    \n                    if (sr != null)\n                    {\n                        // 1. 현재 선택된 타일셋에서 벽 스프라이트 정보를 가져옵니다.\n                        Sprite[] decoratives = selectedTileSet.decorativeWallSprites;\n                        Sprite baseSprite = selectedTileSet.baseWallSprite; // 배열이 아닌 단일 스프라이트\n\n                        // 2. 장식 타일 배열이 비어있지 않고, 설정된 확률을 통과했는지 확인합니다.\n                        if (decoratives != null \u0026\u0026 decoratives.Length \u003e 0 \u0026\u0026 Random.value \u003c decorativeTileChance)\n                        {\n                            // 장식 타일 중 하나를 무작위로 선택하여 적용합니다.\n                            sr.sprite = decoratives[Random.Range(0, decoratives.Length)];\n                        }\n                        // 3. 그렇지 않고, 기본 벽 스프라이트가 설정되어 있다면 그것을 적용합니다.\n                        else if (baseSprite != null)\n                        {\n                            // 단일 기본 스프라이트를 직접 적용합니다.\n                            sr.sprite = baseSprite;\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\n"])</script><script>self.__next_f.push([1,"21:T4df2,"])</script><script>self.__next_f.push([1,"using System.Collections.Generic;\nusing System.Linq;\nusing UnityEngine;\nusing TMPro;\nusing UnityEngine.UI;\n\npublic class WeightedRandomReward : MonoBehaviour\n{\n    [Header(\"Player References\")]\n    public PlayerHP playerHP;\n    public PlayerSP playerSP;\n    public PlayerTowerCost playerTowerCost;\n    public PlayerGold playerGold;\n    public PlayerUpgrade playerUpgrade;\n    public TowerSpawner towerSpawner;\n    public GameManager gameManager;\n    public WaveSystem waveSystem;\n\n    [Header(\"Reward UI Elements\")]\n    public GameObject rewardUIPrefab;\n    public Transform rewardUIParent;\n\n    private Reward[] randRewards;\n\n    private void OnEnable()\n    {\n        foreach (Transform child in rewardUIParent)\n        {\n            Destroy(child.gameObject);\n        }\n\n        bool isFirstWavePerk = (waveSystem != null \u0026\u0026 waveSystem.CurrentWave == 1);\n        List\u003cReward\u003e rewardPoolSource;\n        Reward skipOption = null;\n\n        // [수정] 1 웨이브와 일반 웨이브 모두에 적용할 '스킵' 옵션을 미리 찾습니다.\n        List\u003cReward\u003e normalRewards = RewardFactory.GetNormalRewards();\n\n        if (isFirstWavePerk)\n        {\n            rewardPoolSource = RewardFactory.GetFirstWavePerks();\n            // 1 웨이브의 스킵 옵션은 '최종 점수 증가(index 6)'를 사용합니다.\n            skipOption = normalRewards.Find(r =\u003e r.index == 6);\n        }\n        else\n        {\n            rewardPoolSource = new List\u003cReward\u003e(normalRewards);\n            \n            // 2 웨이브 이후의 스킵 옵션은 '보상 스킵(index 8)'을 사용합니다.\n            skipOption = rewardPoolSource.Find(r =\u003e r.index == 8);\n            if (skipOption != null)\n            {\n                rewardPoolSource.Remove(skipOption); // 추첨 목록에서는 제거\n            }\n        }\n\n        List\u003cReward\u003e temporaryRewardPool = new List\u003cReward\u003e(rewardPoolSource);\n        int numRewardsToShow = gameManager != null ? gameManager.numberOfRewardsToShow : 2;\n    \n        // 최종 UI 패널 개수는 랜덤 보상 + 스킵 보상(있을 경우)\n        int finalPanelCount = skipOption != null ? numRewardsToShow + 1 : numRewardsToShow;\n        randRewards = new Reward[finalPanelCount];\n\n        // 1. 랜덤 보상 생성 (중복 방지)\n        // 1웨이브가 아니면서 '과부하 코어'가 활성화된 경우를 확인하는 조건문 추가\n        if (!isFirstWavePerk \u0026\u0026 GameManager.isSPRewardFixed)\n        {\n            // '과부하 코어' 활성화 시: 첫 보상을 SP로 고정합니다.\n            Reward spReward = FixSPReward();\n            if (spReward != null)\n            {\n                randRewards[0] = spReward; // 첫 번째 슬롯(index 0)에 SP 보상을 고정\n                temporaryRewardPool.RemoveAll(r =\u003e r.index == 2); // 중복을 막기 위해 추첨 목록에서 SP 보상(index 2) 제거\n            }\n\n            // 나머지 보상(numRewardsToShow - 1개)만 랜덤으로 추첨합니다.\n            for (int i = 0; i \u003c numRewardsToShow - 1; i++)\n            {\n                if (temporaryRewardPool.Count == 0) break;\n                Reward selectedReward = RandomReward(temporaryRewardPool);\n                if (selectedReward == null) continue;\n        \n                temporaryRewardPool.RemoveAll(r =\u003e r.index == selectedReward.index);\n                randRewards[i + 1] = selectedReward; // 두 번째 슬롯(index 1)부터 채워나갑니다.\n            }\n        }\n        else\n        {\n            // '과부하 코어'가 비활성화되었거나 1웨이브일 경우, 기존의 완전 랜덤 로직을 실행합니다.\n            for (int i = 0; i \u003c numRewardsToShow; i++)\n            {\n                if (temporaryRewardPool.Count == 0) break;\n                Reward selectedReward = RandomReward(temporaryRewardPool);\n                if (selectedReward == null) continue;\n        \n                temporaryRewardPool.RemoveAll(r =\u003e r.index == selectedReward.index);\n                randRewards[i] = selectedReward;\n            }\n        }\n\n        // 2. 고정 스킵 보상 추가\n        if (skipOption != null)\n        {\n            randRewards[numRewardsToShow] = skipOption;\n        }\n        \n        // 3. 최종적으로 randRewards 배열에 담긴 모든 보상들을 UI로 생성합니다.\n        for (int i = 0; i \u003c randRewards.Length; i++)\n        {\n            // 배열에 이미 저장된 보상을 순서대로 가져옵니다. (다시 뽑지 않음)\n            Reward selectedReward = randRewards[i]; \n            if (selectedReward == null) continue;\n\n            GameObject rewardUI = Instantiate(rewardUIPrefab, rewardUIParent);\n            Button rewardButton = rewardUI.GetComponent\u003cButton\u003e();\n            int buttonIndex = i;\n            rewardButton.onClick.AddListener(() =\u003e RewardButton(buttonIndex));\n\n            Image panelBackground = rewardUI.GetComponent\u003cImage\u003e();\n            Image rewardImage = rewardUI.transform.Find(\"ImageReward\").GetComponent\u003cImage\u003e();\n            TextMeshProUGUI rewardText = rewardUI.transform.Find(\"TextReward\").GetComponent\u003cTextMeshProUGUI\u003e();\n\n            // 웨이브 보상 로직\n            if (isFirstWavePerk)\n            {\n                if (panelBackground != null) panelBackground.color = new Color(0.53f, 0.81f, 0.98f);\n                if (rewardImage != null) rewardImage.gameObject.SetActive(false);\n                if (rewardText != null) rewardText.text = selectedReward.desc;\n            }\n            else\n            {\n                \n                \n                if (panelBackground != null) panelBackground.color = Color.white;\n                if (rewardImage != null)\n                {\n                    rewardImage.gameObject.SetActive(true);\n                    rewardImage.sprite = selectedReward.sprite;\n                }\n\n                if (selectedReward.index == 1)\n                {\n                    selectedReward.value = CalculateRewardGold(waveSystem.CurrentWave - 1);\n                }\n\n                if (rewardText != null)\n                {\n                    if (selectedReward.index == 7)\n                    {\n                        panelBackground.color = Color.yellow; // 장비 보상은 노란색 배경\n                        float scoreForLoot = (DifficultyManager.Instance.CurrentDifficultyLevel * 10000f) + (gameManager.CurrentMapDifficulty.TotalScore * 10f);\n                        PlayerEquipmentInstance droppedEquipment = LootManager.Instance.DropRewardEquipment(scoreForLoot);\n                        if (droppedEquipment != null)\n                        {\n                            // 획득할 장비가 이미 보유 중인지 확인\n                            bool isDuplicate = EquipmentManager.Instance.currentPlayerData.ownedEquipmentInstances.Any(e =\u003e e.equipmentID == droppedEquipment.equipmentID);\n\n                            if (isDuplicate)\n                            {\n                                // 중복일 경우, 보상 정보를 RCoin으로 변환!\n                                EquipmentDataModel data = droppedEquipment.equipmentData;\n                                int rCoinAmount = 0;\n                                switch (data.rarity)\n                                {\n                                    case Rarity.Common: rCoinAmount = 10000; break;\n                                    case Rarity.Uncommon: rCoinAmount = 20000; break;\n                                    case Rarity.Rare: rCoinAmount = 50000; break;\n                                    case Rarity.Epic: rCoinAmount = 100000; break;\n                                    case Rarity.Legendary: rCoinAmount = 200000; break;\n                                }\n\n                                selectedReward.index = 999; // RCoin 변환을 위한 임의의 인덱스 설정\n                                selectedReward.value = rCoinAmount;\n                                \n                                if(rewardImage != null) rewardImage.sprite = Resources.Load\u003cSprite\u003e(data.iconPath);\n                                \n                                string rarityColor = GetColorForRarity(data.rarity);\n                                string equipmentNameText = $\"\u003ccolor={rarityColor}\u003e{data.equipmentName}\\n(중복)\u003c/color\u003e\";\n                                string rCoinText = $\"RCoin\\n+{rCoinAmount}\";\n                                rewardText.text = $\"{equipmentNameText}\\n{rCoinText}\";\n                            }\n                            else\n                            {\n                                selectedReward.acquiredEquipment = droppedEquipment;\n                                if(rewardImage != null) rewardImage.sprite = Resources.Load\u003cSprite\u003e(droppedEquipment.equipmentData.iconPath);\n                                rewardText.text = $\"{droppedEquipment.equipmentData.equipmentName} ({droppedEquipment.equipmentData.rarity})\";\n                            }\n                        }\n                    }\n                    else if (selectedReward.index == 6 || selectedReward.index == 8)\n                    {\n                        rewardText.text = selectedReward.desc;\n                    }\n                    else if (selectedReward.index == 3 || selectedReward.index == 4) // 업그레이드 설명 추가\n                    {\n                        rewardText.text = selectedReward.desc + \"\\n+\" + playerUpgrade.GetUpgradeCountByWave();\n                    }\n                    else if (selectedReward.value != 0)\n                    {\n                        rewardText.text = selectedReward.value + selectedReward.desc;\n                    }\n                    else\n                    {\n                        rewardText.text = selectedReward.desc;\n                    }\n                }\n            }\n        }\n    }\n\n    public Reward RandomReward(List\u003cReward\u003e rewardPool)\n    {\n        List\u003cReward\u003e availableRewards = new List\u003cReward\u003e(rewardPool);\n        if (playerHP.CurrentHP \u003e= playerHP.MaxHP)\n        {\n            availableRewards.RemoveAll(r =\u003e r.index == 0);\n        }\n        \n        // '타워 전문가' 특성 활성화 시 SP 보상을 제외합니다.\n        if (PerkManager.Instance != null \u0026\u0026 PerkManager.Instance.perk_isTowerSpecialistEnabled)\n        {\n            availableRewards.RemoveAll(r =\u003e r.index == 2); // SP 보상(index 2) 제외\n        }\n        \n        int currentTotalWeight = 0;\n        foreach(var reward in availableRewards) currentTotalWeight += reward.weight;\n        if(currentTotalWeight \u003c= 0) return null;\n\n        int selectNum = Random.Range(0, currentTotalWeight) + 1;\n        int weight = 0;\n        \n        foreach(var reward in availableRewards)\n        {\n            weight += reward.weight;\n            if (selectNum \u003c= weight)\n            {\n                Reward temp = new Reward(reward);\n                if (temp.index \u003c 3 || temp.index == 5)\n                {\n                    if(reward.maxRange \u003e reward.minRange)\n                        temp.value = reward.value * (Random.Range(reward.minRange, reward.maxRange));\n                }\n                return temp;\n            }\n        }\n        return null;\n    }\n\n    public void RewardButton(int type)\n    {\n        // 플레이어가 선택한 보상 기록 (수정됨)\n        if (GameAnalyticsManager.Instance != null)\n        {\n            string rewardName = randRewards[type].name;\n\n            // rewardName이 비어있는 경우를 대비한 방어 코드\n            if (string.IsNullOrEmpty(rewardName))\n            {\n                // 이름이 없으면 설명(desc)을 대신 사용\n                rewardName = randRewards[type].desc;\n\n                // 설명도 비어있으면 임시 이름 사용\n                if (string.IsNullOrEmpty(rewardName))\n                {\n                    rewardName = $\"Unnamed_Reward_Index_{randRewards[type].index}\";\n                }\n            }\n            \n            // 장비 보상의 경우, 실제 장비 이름으로 기록 (기존 로직 유지)\n            if (randRewards[type].index == 7 \u0026\u0026 randRewards[type].acquiredEquipment != null)\n            {\n                rewardName = randRewards[type].acquiredEquipment.equipmentData.equipmentName;\n            }\n            GameAnalyticsManager.Instance.RecordRandomRewardChoice(rewardName);\n        }\n        \n        int index = randRewards[type].index;\n        \n        switch (index)\n        {\n            // --- 기존 일반 보상 ---\n            case 0: playerHP.HealHP(randRewards[type].value); break;\n            case 1: playerGold.CurrentGold += randRewards[type].value; break;\n            case 2: playerSP.CurrentSkillPoint = Mathf.Min(playerSP.MaxSP, playerSP.CurrentSkillPoint + randRewards[type].value); break;\n            case 3: playerUpgrade.RewardPhysicUpgrade(); break;\n            case 4: playerUpgrade.RewardMagicUpgrade(); break;\n            case 5: \n                if (gameManager != null \u0026\u0026 gameManager.TowerArchetypes != null \u0026\u0026 gameManager.TowerArchetypes.Length \u003e 0)\n                {\n                    towerSpawner.SpawnRewardTower(gameManager.TowerArchetypes[Random.Range(0, gameManager.TowerArchetypes.Length)]);\n                }\n                break;\n            case 6: // 최종 점수 증가\n            case 8: // 보상 스킵\n                if (GameManager.Instance != null)\n                {\n                    if (GameModeManager.CurrentMode == GameMode.Normal)\n                    {\n                        // 보상 객체에 저장된 value 값을 가져와 더해줍니다.\n                        GameManager.Instance.bonusScore += randRewards[type].value;\n                    }\n                    else\n                    {\n                        GameManager.Instance.infiniteModeScore += randRewards[type].value;\n                    }\n                }\n                break;\n            case 7: \n                if (randRewards[type].acquiredEquipment != null)\n                {\n                    EquipmentManager.Instance.AddEquipmentToPlayer(randRewards[type].acquiredEquipment);\n                }\n                break;\n                \n            // --- 새로운 시작 특성 활성화 ---\n            case 201: PerkManager.Instance.perk_isExplosionEnabled = true; break;\n            case 202: PerkManager.Instance.perk_isExecutionerEnabled = true; break;\n            case 203: // 희생 전략\n                if (gameManager != null \u0026\u0026 gameManager.TowerArchetypes != null \u0026\u0026 gameManager.TowerArchetypes.Length \u003e 0)\n                {\n                    int sacrificedIndex = Random.Range(0, gameManager.TowerArchetypes.Length);\n                    PerkManager.Instance.perk_isSacrificeEnabled = true;\n                    PerkManager.Instance.perk_sacrificedTowerIndex = sacrificedIndex;\n                    PerkManager.Instance.perk_sacrificeDamageBonus = 0.25f; // 25%\n        \n                    // GameManager의 함수를 호출하여 UI를 비활성화합니다.\n                    GameManager.Instance.DisableSacrificedTowerUI(sacrificedIndex);\n                }\n                break;\n            case 204: PerkManager.Instance.perk_hasInterest = true; break;\n            case 205: \n                PerkManager.Instance.perk_upgradeCostModifier = 0.75f; \n                playerUpgrade.RewardPhysicUpgrade();\n                playerUpgrade.RewardMagicUpgrade();\n                break; // 25% 할인\n            case 206: // 위험 수당\n                PerkManager.Instance.perk_enemySpeedModifier = 1.15f; // 15% 증가\n                PerkManager.Instance.perk_goldModifier = 1.2f;      // 20% 증가\n                break;\n            case 207: PerkManager.Instance.perk_isFirstStrikeEnabled = true; break;\n            case 208: // 자원 증폭\n                if (GameModeManager.CurrentMode == GameMode.Normal)\n                {\n                    PerkManager.Instance.perk_towerCostPerWave = 130;\n                }\n                else\n                {\n                    PerkManager.Instance.perk_towerCostPerWave = 30;\n                }\n                playerTowerCost.AddTowerCost(30);\n                break;\n            case 209: // 타워 전문가\n                PerkManager.Instance.perk_isTowerSpecialistEnabled = true;\n                if (GameModeManager.CurrentMode == GameMode.Normal)\n                {\n                    PerkManager.Instance.perk_towerCostPerWave = 200;\n                }\n                else\n                {\n                    PerkManager.Instance.perk_towerCostPerWave = 100;\n                }\n                playerTowerCost.AddTowerCost(100); // 즉시 1회 지급\n                break;\n            case 210: PerkManager.Instance.perk_hasIndomitableWill = true; break;\n            case 999:\n                EquipmentManager.Instance.currentPlayerData.rCoin += randRewards[type].value;\n                // UIEventManager를 통해 RCoin 획득 알림을 보낼 수도 있습니다.\n                break;\n        }\n        \n        if (TutorialManager.Instance != null \u0026\u0026 TutorialManager.Instance.isActiveAndEnabled)\n        {\n            // 시간을 다시 흐르게 하고 다음 튜토리얼 단계로 진행시킵니다.\n            Time.timeScale = 1f;\n            TutorialManager.Instance.ProceedToNextStep();\n        }\n        \n        SoundManager.Instance.PlaySFX(\"SFX_UI_ButtonClick2\"); // 보상패널 선택 사운드\n        \n        gameObject.SetActive(false);\n        if (waveSystem != null)\n        {\n            waveSystem.OnRewardSelected();\n        }\n    }\n\n    private int CalculateRewardGold(int waveIndex)\n    {\n        int calculatedGold = 200;\n        calculatedGold += (50 * waveIndex);\n        int thresholdWave = 20;\n        if (waveIndex \u003e= thresholdWave)\n        {\n            int effectiveIndex = waveIndex - thresholdWave + 1;\n            calculatedGold += (200 * effectiveIndex * effectiveIndex);\n        }\n        return calculatedGold;\n    }\n\n    private Reward FixSPReward()\n    {\n        Reward spRewardTemplate = RewardFactory.GetNormalRewards().Find(r =\u003e r.index == 2);\n        if (spRewardTemplate != null)\n        {\n            Reward spReward = new Reward(spRewardTemplate);\n            if (playerSP != null)\n            {\n                spReward.value = Mathf.FloorToInt(playerSP.MaxSP * 0.2f); \n                if (spReward.value == 0) spReward.value = 20;\n            }\n            else\n            {\n                spReward.value = 50;\n            }\n            return spReward;\n        }\n        return null;\n    }\n    \n    /// \u003csummary\u003e\n    /// 장비 등급에 맞는 색상 코드를 반환합니다.\n    /// \u003c/summary\u003e\n    private string GetColorForRarity(Rarity rarity)\n    {\n        switch (rarity)\n        {\n            case Rarity.Common: return \"#808080\"; // 회색\n            case Rarity.Uncommon: return \"green\";   // 초록색\n            case Rarity.Rare: return \"blue\";    // 파란색\n            case Rarity.Epic: return \"purple\";  // 보라색\n            case Rarity.Legendary: return \"orange\";  // 주황색\n            default: return \"black\";   // 기본값\n        }\n    }\n\n    [System.Serializable]\n    public class Reward\n    {\n        public int index;\n        public Sprite sprite;\n        public string name;\n        public string desc;\n        public int value;\n        public int minRange;\n        public int maxRange;\n        public int weight;\n        public TowerArchetype towerArchetype;\n        public PlayerEquipmentInstance acquiredEquipment;\n        public Reward() {}\n        public Reward(Reward reward)\n        {\n            this.index = reward.index;\n            this.sprite = reward.sprite;\n            this.name = reward.name;\n            this.desc = reward.desc;\n            this.value = reward.value;\n            this.minRange = reward.minRange;\n            this.maxRange = reward.maxRange;\n            this.weight = reward.weight;\n            this.towerArchetype = reward.towerArchetype;\n        }\n    }\n}"])</script><script>self.__next_f.push([1,"e:[\"$\",\"main\",null,{\"className\":\"mx-auto max-w-6xl px-4 py-16 space-y-12\",\"children\":[[\"$\",\"section\",null,{\"className\":\"grid gap-8 md:grid-cols-2 items-stretch\",\"children\":[[\"$\",\"div\",null,{\"className\":\"rounded-xl overflow-hidden shadow-sm\",\"children\":[\"$\",\"$Lf\",null,{\"src\":\"/SiteLogo.png\",\"alt\":\"RogueTower 메인\",\"className\":\"w-full h-full object-cover\"}]}],[\"$\",\"div\",null,{\"className\":\"flex flex-col justify-between\",\"children\":[[\"$\",\"div\",null,{\"children\":[[\"$\",\"h1\",null,{\"className\":\"text-4xl font-bold underline decoration-blue-500 underline-offset-8\",\"children\":\"RogueTower\"}],[\"$\",\"dl\",null,{\"className\":\"grid grid-cols-[120px_1fr] gap-x-4 gap-y-6 text-gray-800 mt-8\",\"children\":[[\"$\",\"dt\",null,{\"className\":\"font-semibold text-gray-600\",\"children\":\"ROLE\"}],[\"$\",\"dd\",null,{\"children\":\"Programmer, Game Designer, Artist\"}],[\"$\",\"dt\",null,{\"className\":\"font-semibold text-gray-600\",\"children\":\"DURATION\"}],[\"$\",\"dd\",null,{\"children\":\"2024.10 ~ 2025.08\"}],[\"$\",\"dt\",null,{\"className\":\"font-semibold text-gray-600\",\"children\":\"TEAM\"}],[\"$\",\"dd\",null,{\"children\":\"1인 개발\"}],[\"$\",\"dt\",null,{\"className\":\"font-semibold text-gray-600\",\"children\":\"PLATFORM\"}],[\"$\",\"dd\",null,{\"children\":\"PC\"}]]}]]}],[\"$\",\"div\",null,{\"className\":\"mt-6 flex gap-4\",\"children\":[\"$\",\"a\",null,{\"href\":\"https://github.com/WooGeun-Nam/RogueTower-Code\",\"target\":\"_blank\",\"rel\":\"noopener noreferrer\",\"className\":\"inline-flex items-center gap-2 rounded-full px-5 py-3 text-sm font-semibold bg-gray-200 text-gray-900 hover:bg-gray-300 focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-blue-300\",\"children\":\"GitHub Source\"}]}]]}]]}],[\"$\",\"section\",null,{\"className\":\"pt-8\",\"children\":[\"$\",\"$L10\",null,{\"codeAssets\":{\"SoundManager\":\"$11\",\"ExceptionReporter\":\"$12\",\"LoadingSceneController\":\"$13\",\"ShopManager\":\"$14\",\"StatueOfDestructionGod\":\"$15\",\"GameManager\":\"$16\",\"GameDataManager\":\"$17\",\"UIManager\":\"$18\",\"UIEventManager\":\"$19\",\"TooltipManager\":\"$1a\",\"TooltipTrigger\":\"$1b\",\"TowerArchetype\":\"$1c\",\"Enemy\":\"$1d\",\"IWeaponState\":\"using System.Collections;\\nusing UnityEngine;\\n\\n/// \u003csummary\u003e\\n/// 타워 무기의 상태를 정의하는 인터페이스입니다.\\n/// 각 상태는 이 인터페이스를 구현하여 무기의 특정 행동을 정의합니다.\\n/// \u003c/summary\u003e\\npublic interface IWeaponState\\n{\\n    /// \u003csummary\u003e\\n    /// 현재 상태의 로직을 실행합니다.\\n    /// \u003c/summary\u003e\\n    /// \u003cparam name=\\\"weapon\\\"\u003e상태를 실행할 TowerWeapon 인스턴스\u003c/param\u003e\\n    /// \u003creturns\u003e상태 로직을 위한 코루틴\u003c/returns\u003e\\n    IEnumerator Execute(TowerWeapon weapon);\\n}\\n\",\"ObjectPool\":\"$1e\",\"RandomPathGenerator\":\"$1f\",\"MapGenerator\":\"$20\",\"WeightedRandomReward\":\"$21\",\"SpecialSkillBase\":\"using UnityEngine;\\n\\n// 스킬의 종류를 정의하는 Enum\\npublic enum SkillType\\n{\\n    Passive,        // 장착 시 지속적으로 효과 적용\\n    Active,         // 플레이어가 직접 사용 (버튼 클릭 등)\\n    Tower    // 특정 타워 설치\\n}\\n\\npublic abstract class SpecialSkillBase : ScriptableObject\\n{\\n    [Header(\\\"스킬 기본 정보\\\")]\\n    public string skillID;\\n    public string skillName;\\n    [TextArea]\\n    public string description;\\n    public Sprite icon;\\n    public SkillType skillType; // 스킬 타입 추가\\n\\n    // 모든 특수 스킬이 구현해야 할 기능들 (추상 메서드)\\n    public abstract void Activate();    // 스킬 활성화 (장착 시) - 씬 독립적인 초기화/정리\\n    public abstract void Deactivate();  // 스킬 비활성화 (해제 시) - 씬 독립적인 초기화/정리\\n\\n    // 스킬 타입에 따라 선택적으로 구현될 메서드\\n    public virtual void UseSkill(GameObject skillButton) { } // 사용형 스킬 (Active)에서 오버라이드\\n    public virtual GameObject GetTowerPrefab() { return null; } // 타워 설치형 스킬 (TowerInstall)에서 오버라이드\\n\\n    // 인게임에서 실제 게임 플레이 효과를 적용/제거하는 메서드 (씬 종속적)\\n    public virtual void ApplyGameEffect() { }\\n    public virtual void RemoveGameEffect() { }\\n}\\n\"}}]}]]}]\n"])</script></body></html>