1:HL["/towerdefense-portfolio/_next/static/media/e4af272ccee01ff0-s.p.woff2","font",{"crossOrigin":"","type":"font/woff2"}]
2:HL["/towerdefense-portfolio/_next/static/css/a2d730245c00c31d.css","style"]
0:["CUYEUkn7BP9F3Usp6IYiX",[[["",{"children":["projects",{"children":["roguetower",{"children":["__PAGE__",{}]}]}]},"$undefined","$undefined",true],"$L3",[[["$","link","0",{"rel":"stylesheet","href":"/towerdefense-portfolio/_next/static/css/a2d730245c00c31d.css","precedence":"next"}]],"$L4"]]]]
5:HL["/towerdefense-portfolio/_next/static/css/986f079464c860c4.css","style"]
6:I{"id":4244,"chunks":["185:static/chunks/app/layout-98f9b8b17decd81b.js"],"name":"","async":false}
7:I{"id":7885,"chunks":["185:static/chunks/app/layout-98f9b8b17decd81b.js"],"name":"","async":false}
8:I{"id":1443,"chunks":["272:static/chunks/webpack-502300a954e5d59c.js","971:static/chunks/fd9d1056-102022806532a78e.js","864:static/chunks/864-434aad9338f96954.js"],"name":"","async":false}
9:I{"id":8639,"chunks":["272:static/chunks/webpack-502300a954e5d59c.js","971:static/chunks/fd9d1056-102022806532a78e.js","864:static/chunks/864-434aad9338f96954.js"],"name":"","async":false}
a:I{"id":3891,"chunks":["616:static/chunks/616-281c6358976a3d84.js","570:static/chunks/app/projects/layout-61601cf7bf20290d.js"],"name":"","async":false}
4:[["$","meta","0",{"charSet":"utf-8"}],["$","title","1",{"children":"WooGeun Nam"}],["$","meta","2",{"name":"description","content":"웹 포트폴리오"}],["$","meta","3",{"name":"viewport","content":"width=device-width, initial-scale=1"}],["$","link","4",{"rel":"icon","href":"./../Logo.ico"}],["$","meta","5",{"name":"next-size-adjust"}]]
3:[null,["$","html",null,{"lang":"ko","className":"scroll-smooth","suppressHydrationWarning":true,"children":[["$","$L6",null,{"src":"https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js","strategy":"afterInteractive"}],["$","$L6",null,{"src":"https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-csharp.min.js","strategy":"afterInteractive"}],["$","$L6",null,{"src":"https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js","strategy":"afterInteractive"}],["$","head",null,{"children":[["$","link",null,{"rel":"stylesheet","href":"https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css"}],["$","link",null,{"rel":"stylesheet","href":"https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.css"}]]}],["$","body",null,{"className":"__className_94e1b1 min-h-dvh bg-gray-100 antialiased","children":[["$","$L7",null,{}],["$","$L8",null,{"parallelRouterKey":"children","segmentPath":["children"],"loading":"$undefined","loadingStyles":"$undefined","hasLoading":false,"error":"$undefined","errorStyles":"$undefined","template":["$","$L9",null,{}],"templateStyles":"$undefined","notFound":[["$","title",null,{"children":"404: This page could not be found."}],["$","div",null,{"style":{"fontFamily":"system-ui,\"Segoe UI\",Roboto,Helvetica,Arial,sans-serif,\"Apple Color Emoji\",\"Segoe UI Emoji\"","height":"100vh","textAlign":"center","display":"flex","flexDirection":"column","alignItems":"center","justifyContent":"center"},"children":["$","div",null,{"children":[["$","style",null,{"dangerouslySetInnerHTML":{"__html":"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}"}}],["$","h1",null,{"className":"next-error-h1","style":{"display":"inline-block","margin":"0 20px 0 0","padding":"0 23px 0 0","fontSize":24,"fontWeight":500,"verticalAlign":"top","lineHeight":"49px"},"children":"404"}],["$","div",null,{"style":{"display":"inline-block"},"children":["$","h2",null,{"style":{"fontSize":14,"fontWeight":400,"lineHeight":"49px","margin":0},"children":"This page could not be found."}]}]]}]}]],"notFoundStyles":[],"childProp":{"current":[null,["$","section",null,{"children":[["$","$La",null,{}],["$","main",null,{"className":"mx-auto w-full max-w-6xl pt-16","children":["$","$L8",null,{"parallelRouterKey":"children","segmentPath":["children","projects","children"],"loading":"$undefined","loadingStyles":"$undefined","hasLoading":false,"error":"$undefined","errorStyles":"$undefined","template":["$","$L9",null,{}],"templateStyles":"$undefined","notFound":"$undefined","notFoundStyles":"$undefined","childProp":{"current":["$","$L8",null,{"parallelRouterKey":"children","segmentPath":["children","projects","children","roguetower","children"],"loading":"$undefined","loadingStyles":"$undefined","hasLoading":false,"error":"$undefined","errorStyles":"$undefined","template":["$","$L9",null,{}],"templateStyles":"$undefined","notFound":"$undefined","notFoundStyles":"$undefined","childProp":{"current":["$Lb","$Lc",null],"segment":"__PAGE__"},"styles":[]}],"segment":"roguetower"},"styles":[]}]}],["$","footer",null,{"className":"py-6 pr-6 text-right text-sm text-gray-500","children":"Copyright © 2025. WooGeun-Nam All rights reserved."}]]}],null],"segment":"projects"},"styles":[["$","link","0",{"rel":"stylesheet","href":"/towerdefense-portfolio/_next/static/css/986f079464c860c4.css","precedence":"next"}]]}]]}]]}],null]
b:null
d:I{"id":2148,"chunks":["899:static/chunks/app/projects/roguetower/page-fe21832f41f7c33a.js"],"name":"","async":false}
e:I{"id":8016,"chunks":["899:static/chunks/app/projects/roguetower/page-fe21832f41f7c33a.js"],"name":"","async":false}
f:T34c3,using UnityEngine;
using UnityEngine.Audio;
using System.Collections.Generic;
using System.Linq;
using System.Collections;

public class SoundManager : MonoBehaviour
{
    public static SoundManager Instance { get; private set; }

    public AudioMixer masterMixer;

    private AudioSource bgmPlayer;
    private List<AudioSource> sfxSources = new List<AudioSource>();
    private Dictionary<GameObject, AudioSource> loopingSfxSources = new Dictionary<GameObject, AudioSource>();
    [Tooltip("동시에 재생할 수 있는 최대 효과음 개수")]
    [SerializeField] private int maxSfxSources = 20; // 인스펙터에서 조절 가능
    
    // 사운드 쿨다운(재생 조절)을 위한 변수들
    [Tooltip("동일한 사운드를 다시 재생하기까지 필요한 최소 시간 간격 (초)")]
    [SerializeField] private float sfxThrottleTime = 0.05f;
    private Dictionary<string, float> _sfxCooldowns = new Dictionary<string, float>();

    private string currentBgmName; // BGM이 바뀔 때마다 이 변수에 이름을 저장
    
    // 오디오 클립 및 분석 데이터를 관리할 Dictionary
    private Dictionary<string, AudioClip[]> audioClips;
    private Dictionary<string, float> clipPeakVolumes = new Dictionary<string, float>(); // 오디오 클립의 피크 볼륨을 캐싱

    private const float TARGET_PEAK_VOLUME = 0.7f; // 볼륨 정규화를 위한 목표 피크 값 (오디오 클리핑 방지를 위해 1.0f 보다 낮게 설정)

    // === 추가된 상수 정의 ===
    private const string GAME_BGM_PREFIX = "BGM_Game_"; // 인게임 BGM 파일을 식별하기 위한 접두사
    private const string TUTORIAL_BGM_NAME = "BGM_Game_1"; // 튜토리얼에서 사용할 BGM 이름
    
    // 초기화 상태를 외부에 알릴 수 있는 변수
    public bool IsInitialized { get; private set; } = false;
    
    public float InitializationProgress { get; private set; } = 0f; // [추가] 초기화 진행률
    
    private void Awake()
    {
        if (Instance == null)
        {
            Instance = this;
            DontDestroyOnLoad(gameObject);

            bgmPlayer = gameObject.AddComponent<AudioSource>();
            bgmPlayer.outputAudioMixerGroup = masterMixer.FindMatchingGroups("BGM")[0];
            
            for (int i = 0; i < maxSfxSources; i++)
            {
                AudioSource sfxSource = gameObject.AddComponent<AudioSource>();
                sfxSource.outputAudioMixerGroup = masterMixer.FindMatchingGroups("SFX")[0];
                sfxSource.loop = false;
                sfxSources.Add(sfxSource);
            }
            
            IsInitialized = false;
            StartCoroutine(LoadAndAnalyzeAudioClipsAsync());
        }
        else
        {
            Destroy(gameObject);
        }
    }

    // === 볼륨 정규화 기능이 적용된 재생 함수 ===

    // 동일한 BGM이 이미 재생 중일 경우 다시 시작하지 않도록 수정
    public void PlayBGM(string clipName, bool loop = true, float volume = 1.0f, float pitch = 1.0f)
    {
        AudioClip clip = FindClip(clipName);
        if (clip == null) return;

        // 현재 재생 중인 클립이 요청된 클립과 동일하면 아무것도 하지 않고 리턴
        if (bgmPlayer.isPlaying && bgmPlayer.clip != null && bgmPlayer.clip.name == clip.name)
        {
            return;
        }

        bgmPlayer.clip = clip;
        bgmPlayer.loop = loop;
        bgmPlayer.volume = GetAdjustedVolume(clipName, volume);
        bgmPlayer.pitch = pitch;
        bgmPlayer.Play();
        
        currentBgmName = clipName; // BGM 이름 저장
    }
    
    // AnalyticsDebugUI에서 호출할 getter 메소드
    public string GetCurrentBGMName()
    {
        if (bgmPlayer != null && bgmPlayer.isPlaying)
        {
            return currentBgmName;
        }
        return "Not Playing";
    }

    //  게임 BGM 랜덤 재생 메서드
    public void PlayRandomGameBGM()
    {
        // 튜토리얼 완료 여부 확인
        if (PlayerPrefs.GetInt("TutorialCompleted", 0) == 0)
        {
            // 튜토리얼 중일 경우, 지정된 튜토리얼 BGM 재생
            PlayBGM(TUTORIAL_BGM_NAME, true);
        }
        else
        {
            // 튜토리얼 완료 시, 랜덤 BGM 재생
            if (audioClips.TryGetValue("BGM", out AudioClip[] bgmClips))
            {
                // "BGM_Game_" 접두사를 가진 모든 BGM 클립을 리스트로 가져옴
                List<AudioClip> gameBgmList = bgmClips.Where(clip => clip.name.StartsWith(GAME_BGM_PREFIX)).ToList();

                if (gameBgmList.Count > 0)
                {
                    // 리스트에서 랜덤하게 BGM 하나를 선택
                    AudioClip randomClip = gameBgmList[Random.Range(0, gameBgmList.Count)];
                    PlayBGM(randomClip.name, true);
                }
                else
                {
                    Debug.LogWarning($"'{GAME_BGM_PREFIX}' 접두사를 가진 게임 BGM을 찾을 수 없습니다.");
                }
            }
        }
    }
    
    public void PlaySFX(string clipName, float volume = 1.0f, float pitch = 1.0f)
    {
        AudioClip clip = FindClip(clipName);
        if (clip == null) return;
        
        // 이전에 이 사운드를 재생한 기록이 있는지 확인합니다.
        if (_sfxCooldowns.ContainsKey(clipName))
        {
            // 마지막 재생 시간과 현재 시간을 비교하여, 설정된 쿨다운 시간(sfxThrottleTime)이 지나지 않았다면
            // 소리를 재생하지 않고 즉시 함수를 종료합니다.
            if (Time.unscaledTime - _sfxCooldowns[clipName] < sfxThrottleTime)
            {
                return;
            }
        }

        // 오디오 소스 풀에서 비어있는 소스를 찾아옵니다.
        AudioSource sourceToPlay = GetAvailableSfxSource();
        if (sourceToPlay == null) return;
        
        // 재생 직전에, 현재 시간을 마지막 재생 시간으로 기록(갱신)합니다.
        _sfxCooldowns[clipName] = Time.unscaledTime;

        // 찾은 소스를 사용하여 효과음을 재생합니다.
        sourceToPlay.pitch = pitch;
        sourceToPlay.PlayOneShot(clip, GetAdjustedVolume(clipName, volume));
    }

    public void PlayLoopingSFX(string clipName, GameObject caller, float volume = 1.0f, float pitch = 1.0f)
    {
        if (loopingSfxSources.ContainsKey(caller))
        {
            // 이미 재생 중인 경우, 볼륨과 피치만 업데이트
            loopingSfxSources[caller].volume = GetAdjustedVolume(clipName, volume); // 볼륨 업데이트 시에도 정규화 적용
            loopingSfxSources[caller].pitch = pitch;
            return;
        }

        AudioClip clip = FindClip(clipName);
        if (clip != null)
        {
            GameObject obj = new GameObject($"LoopingSFX_{clipName}_{caller.name}");
            obj.transform.SetParent(transform);
            AudioSource source = obj.AddComponent<AudioSource>();
            source.outputAudioMixerGroup = masterMixer.FindMatchingGroups("SFX")[0];
            source.clip = clip;
            source.loop = true;
            source.volume = GetAdjustedVolume(clipName, volume); // 정규화된 볼륨 적용
            source.pitch = pitch;
            source.Play();
            loopingSfxSources.Add(caller, source);
        }
    }

    // === 오디오 클립 로드 및 분석 로직 ===
    
    // [수정] 동기 함수를 비동기 코루틴으로 변경
    private IEnumerator LoadAndAnalyzeAudioClipsAsync()
    {
        audioClips = new Dictionary<string, AudioClip[]>();
        clipPeakVolumes = new Dictionary<string, float>();

        // 지정된 모든 경로의 오디오 클립을 비동기로 로드하고 분석
        yield return StartCoroutine(LoadClipsFromPathAsync("BGM"));
        yield return StartCoroutine(LoadClipsFromPathAsync("Tower"));
        yield return StartCoroutine(LoadClipsFromPathAsync("Enemy"));
        yield return StartCoroutine(LoadClipsFromPathAsync("Skill"));
        yield return StartCoroutine(LoadClipsFromPathAsync("UI"));
        yield return StartCoroutine(LoadClipsFromPathAsync("System"));
        IsInitialized = true; // 모든 로딩이 완료되었음을 알립니다.
    }

    // [수정] 경로에서 오디오 클립을 비동기로 로드하는 코루틴
    private IEnumerator LoadClipsFromPathAsync(string path)
    {
        // 1. 먼저 경로에 있는 모든 클립의 참조를 동기적으로 가져옵니다. (이 과정은 매우 빠름)
        AudioClip[] clips = Resources.LoadAll<AudioClip>("Sound/" + path);

        if (clips.Length > 0)
        {
            // 2. 클립 배열을 저장
            audioClips.Add(path, clips);
        
            // 3. 각 클립에 대해 비동기 로딩 및 분석을 진행합니다.
            foreach (AudioClip clip in clips)
            {
                if (!clipPeakVolumes.ContainsKey(clip.name))
                {
                    string fullPath = "Sound/" + path + "/" + clip.name;

                    ResourceRequest request = Resources.LoadAsync<AudioClip>(fullPath);
                
                    // 로딩이 완료될 때까지 기다립니다.
                    while (!request.isDone)
                    {
                        yield return null;
                    }
                    // 로딩이 완료된 클립을 분석합니다.
                    float peakVolume = AnalyzeClipPeakVolume((AudioClip)request.asset);
                    clipPeakVolumes.Add(clip.name, peakVolume);
                }
            }
        }
    }

    private float AnalyzeClipPeakVolume(AudioClip clip)
    {
        // 클립의 모든 오디오 샘플 데이터를 가져옴
        float[] samples = new float[clip.samples * clip.channels];
        clip.GetData(samples, 0);

        float peakVolume = 0f;
        for (int i = 0; i < samples.Length; i++)
        {
            // 샘플의 절대값이 현재 피크 값보다 크면 업데이트
            float currentSample = Mathf.Abs(samples[i]);
            if (currentSample > peakVolume)
            {
                peakVolume = currentSample;
            }
        }
        return peakVolume;
    }

    private float GetAdjustedVolume(string clipName, float originalVolume)
    {
        if (clipPeakVolumes.TryGetValue(clipName, out float peakVolume))
        {
            // 피크 볼륨이 매우 작으면(거의 무음이면) 과도하게 증폭되는 것을 방지
            if (peakVolume < 0.01f)
            {
                return originalVolume;
            }
            // 목표 피크 볼륨을 기준으로 정규화된 볼륨 계산
            return originalVolume * (TARGET_PEAK_VOLUME / peakVolume);
        }
        return originalVolume; // 분석 데이터가 없는 경우 원래 볼륨 사용
    }

    // === 기존 유틸리티 함수들 (변경 없음) ===

    public void StopLoopingSFX(GameObject caller)
    {
        if (loopingSfxSources.ContainsKey(caller))
        {
            AudioSource source = loopingSfxSources[caller];
            if (source != null)
            {
                source.Stop();
                Destroy(source.gameObject);
            }
            loopingSfxSources.Remove(caller);
        }
    }

    public void StopAllLoopingSFX()
    {
        foreach (var entry in loopingSfxSources)
        {
            entry.Value.Stop();
            Destroy(entry.Value.gameObject);
        }
        loopingSfxSources.Clear();
    }

    public void SetBGMVolume(float volume)
    {
        float dB = ConvertVolumeToDb(volume);
        masterMixer.SetFloat("BGMVolume", dB);
    }

    public void SetSFXVolume(float volume)
    {
        float dB = ConvertVolumeToDb(volume);
        masterMixer.SetFloat("SFXVolume", dB);
    }

    public void SetMasterVolume(float volume)
    {
        float dB = ConvertVolumeToDb(volume);
        masterMixer.SetFloat("MasterVolume", dB);
    }

    private float ConvertVolumeToDb(float volume)
    {
        return volume > 0.0001f ? Mathf.Log10(volume) * 20 : -80f;
    }

    public void StopAllSounds()
    {
        bgmPlayer.Stop();
        
        // sfxPlayer.Stop(); // 기존 코드 삭제
        foreach (var source in sfxSources)
        {
            source.Stop();
        }

        StopAllLoopingSFX();
    }

    public AudioClip FindClip(string clipName)
    {
        foreach (var key in audioClips.Keys)
        {
            foreach (var clip in audioClips[key])
            {
                if (clip.name.Equals(clipName))
                {
                    return clip;
                }
            }
        }
        Debug.LogWarning($"AudioClip not found: {clipName}"); // 클립을 찾지 못했을 때 경고 메시지 추가
        return null;
    }
    
    private AudioSource GetAvailableSfxSource()
    {
        // sfxSources 리스트를 처음부터 순회합니다.
        foreach (var source in sfxSources)
        {
            // 현재 재생 중이 아닌 소스를 찾으면, 그 소스를 즉시 반환합니다.
            if (!source.isPlaying)
            {
                return source;
            }
        }
        
        // 모든 소스가 사용 중이라면(위의 반복문에서 반환되지 않았다면), null을 반환합니다.
        return null;
    }
}10:Te7c,using UnityEngine;
using PlayFab;
using PlayFab.ClientModels;
using System.Collections.Generic;

/// <summary>
/// 게임 중 발생하는 치명적인 예외(Exception)를 감지하여 PlayFab으로 전송하는 클래스.
/// 이 스크립트를 가진 빈 게임 오브젝트를 만들어 첫 씬에 배치하세요.
/// </summary>
public class ExceptionReporter : MonoBehaviour
{
    public static ExceptionReporter Instance { get; private set; }
    
    // 한 세션에서 동일한 오류가 반복적으로 전송되는 것을 막기 위한 Set
    private HashSet<string> _sentExceptionsThisSession = new HashSet<string>();

    private void Awake()
    {
        if (Instance == null)
        {
            Instance = this;
            DontDestroyOnLoad(gameObject);
        }
        else
        {
            Destroy(gameObject);
        }
    }

    private void OnEnable()
    {
        // Unity의 로그 메시지 이벤트를 구독합니다.
        Application.logMessageReceived += HandleLog;
    }

    private void OnDisable()
    {
        // 구독을 해제합니다.
        Application.logMessageReceived -= HandleLog;
    }

    /// <summary>
    /// Unity의 모든 로그 메시지가 호출될 때 실행되는 핸들러 메서드입니다.
    /// </summary>
    /// <param name="logString">오류 메시지</param>
    /// <param name="stackTrace">호출 스택</param>
    /// <param name="type">로그 타입 (Log, Warning, Error, Exception 등)</param>
    private void HandleLog(string logString, string stackTrace, LogType type)
    {
        // 로그 타입이 Exception일 경우에만 처리합니다.
        // (Warning이나 Error까지 보내면 너무 많은 데이터가 쌓일 수 있습니다.)
        if (type == LogType.Exception)
        {
            // 이 세션에서 이미 보낸적 있는 오류 메시지라면 건너뜁니다. (서버 과부하 방지)
            if (_sentExceptionsThisSession.Contains(logString))
            {
                return;
            }
            
            // PlayFab 클라이언트가 로그인 상태인지 확인합니다.
            if (!PlayFabClientAPI.IsClientLoggedIn())
            {
                return;
            }
            
            // 전송할 데이터를 구성합니다.
            var request = new WriteClientPlayerEventRequest
            {
                EventName = "client_exception", // 이벤트 이름
                Body = new Dictionary<string, object>
                {
                    { "error_message", logString }, // 실제 오류 메시지
                    { "stack_trace", stackTrace },   // 호출 스택 (가장 중요!)
                    { "game_version", Application.version }, // 게임 버전
                    { "scene_name", UnityEngine.SceneManagement.SceneManager.GetActiveScene().name } // 오류 발생 씬
                    // 필요하다면 다른 유용한 정보 (예: 플레이어 레벨, 현재 웨이브 등)를 추가할 수 있습니다.
                }
            };
            
            // PlayFab으로 이벤트 전송
            PlayFabClientAPI.WritePlayerEvent(request, 
                result => {
                    Debug.Log("<color=orange>[ExceptionReporter] 치명적 오류 정보를 PlayFab으로 전송했습니다.</color>");
                },
                error => {
                    Debug.LogError("[ExceptionReporter] 오류 정보 전송 실패: " + error.GenerateErrorReport());
                }
            );
            
            // 보낸 오류 목록에 추가하여 중복 전송을 방지합니다.
            _sentExceptionsThisSession.Add(logString);
        }
    }
}11:Te78,using System.Collections;
using UnityEngine;
using UnityEngine.UI;
using UnityEngine.SceneManagement;
using TMPro;

/// <summary>
/// 로딩 씬을 관리하고 비동기적으로 씬을 로드하는 클래스
/// </summary>
public class LoadingSceneController : MonoBehaviour
{
    private static string nextScene; // 다음으로 로드할 씬의 이름

    [Tooltip("로딩 진행률을 표시하는 슬라이더 UI")]
    public Slider progressBar;
    [Tooltip("로딩 상태 텍스트를 표시하는 UI")]
    public TextMeshProUGUI loadText;
    
    private void Start()
    {
        // ProgressBar의 값을 항상 0으로 초기화합니다.
        progressBar.value = 0f;
        
        // 모든 사운드 중지
        if (SoundManager.Instance != null)
        {
            SoundManager.Instance.StopAllSounds();
        }

        StartCoroutine(LoadSceneWithCleanup());
    }

    /// <summary>
    /// 지정된 씬으로 로딩 씬을 통해 전환합니다.
    /// </summary>
    /// <param name="sceneName">로드할 씬의 이름</param>
    public static void LoadScene(string sceneName)
    {
        nextScene = sceneName;
        SceneManager.LoadScene("LoadingScene");
    }

    /// <summary>
    /// [수정] 리소스 정리와 씬 로딩을 함께 처리하는 최종 코루틴입니다.
    /// </summary>
    private IEnumerator LoadSceneWithCleanup()
    {
        yield return null; // 한 프레임 대기하여 UI가 제대로 표시될 시간을 줌

        // --- 1단계: 리소스 정리 (프로그레스 바 0% -> 50%) ---
        if (loadText != null) loadText.text = "Cleaning up resources...";
        
        // 사용되지 않는 에셋을 메모리에서 강제로 해제합니다.
        AsyncOperation unloadOperation = Resources.UnloadUnusedAssets();
        while (!unloadOperation.isDone)
        {
            // 정리 과정 동안 프로그레스 바를 0%에서 50%까지 채웁니다.
            if (progressBar != null) progressBar.value = unloadOperation.progress * 0.5f;
            if (loadText != null) loadText.text = $"Cleaning up... {progressBar.value * 100:F0}%";
            yield return null;
        }

        // 가비지 컬렉터를 수동으로 호출하여 메모리를 정리합니다.
        System.GC.Collect();
        // Debug.Log("리소스 정리 및 가비지 컬렉션 완료.");

        // --- 2단계: 다음 씬 비동기 로드 (프로그레스 바 50% -> 100%) ---
        if (loadText != null) loadText.text = "Loading scene...";
        
        AsyncOperation operation = SceneManager.LoadSceneAsync(nextScene);
        operation.allowSceneActivation = false;

        float timer = 0f;
        while (!operation.isDone)
        {
            yield return null;

            if (operation.progress < 0.9f)
            {
                // 씬 로딩 과정을 프로그레스 바의 50%에서 95%까지 채웁니다. (0.5f + progress * 0.45f)
                progressBar.value = 0.5f + (operation.progress * 0.45f);
                if (loadText != null) loadText.text = $"Loading... {progressBar.value * 100:F0}%";
            }
            else
            {
                // 씬 로딩이 거의 끝나면 95%에서 100%까지 부드럽게 채웁니다.
                timer += Time.unscaledDeltaTime;
                progressBar.value = Mathf.Lerp(0.95f, 1f, timer);
                if (loadText != null) loadText.text = $"Loading... {progressBar.value * 100:F0}%";

                if (progressBar.value >= 1f)
                {
                    operation.allowSceneActivation = true; // 씬 활성화
                    yield break;
                }
            }
        }
    }
}
12:T1feb,using UnityEngine;
using TMPro;
using UnityEngine.UI;
using System.Collections;
using System.Collections.Generic;

public enum GachaType
{
    Normal,
    Advanced,
    Rare
}

public class ShopManager : MonoBehaviour
{
    public static ShopManager Instance { get; private set; }

    [Header("Gacha Settings")]
    [Tooltip("일반 뽑기 비용")]
    [SerializeField] private int normalGachaCost = 50000;
    [Tooltip("고급 뽑기 비용")]
    [SerializeField] private int advancedGachaCost = 100000;
    [Tooltip("희귀 뽑기 비용")]
    [SerializeField] private int rareGachaCost = 200000;
    [SerializeField] private float gachaAnimationDuration = 2f;

    [Header("UI References")]
    [SerializeField] private TextMeshProUGUI rCoinText;
    [SerializeField] private Button normalDrawButton;
    [SerializeField] private Button advancedDrawButton;
    [SerializeField] private Button rareDrawButton;
    
    [Header("Animation Panel")]
    [SerializeField] private GameObject gachaAnimationPanel;
    [SerializeField] private Image rewardImage;
    [SerializeField] private TextMeshProUGUI rewardNameText;
    [SerializeField] private TextMeshProUGUI rewardDescriptionText;
    [SerializeField] private Slider gachaSlider;
    [SerializeField] private GameObject gachaCloseButton; // [추가] 닫기 버튼의 GameObject를 연결할 변수

    private bool isGachaInProgress = false;

    private void Awake()
    {
        if (Instance == null) Instance = this;
        else Destroy(gameObject);
    }

    private void OnEnable()
    {
        UpdateRCoinDisplay();
        if (gachaAnimationPanel != null)
        {
            gachaAnimationPanel.SetActive(false);
        }
    }

    public void UpdateRCoinDisplay()
    {
        if (EquipmentManager.Instance != null && EquipmentManager.Instance.currentPlayerData != null)
        {
            int currentRCoin = EquipmentManager.Instance.currentPlayerData.rCoin;
            rCoinText.text = currentRCoin.ToString("N0");
            
            if (!isGachaInProgress)
            {
                normalDrawButton.interactable = currentRCoin >= normalGachaCost;
                advancedDrawButton.interactable = currentRCoin >= advancedGachaCost;
                rareDrawButton.interactable = currentRCoin >= rareGachaCost;
            }
        }
    }

    public void OnClickDraw(int gachaTypeIndex)
    {
        if (isGachaInProgress) return;

        // 숫자로 받은 타입을 Enum으로 변환
        GachaType type = (GachaType)gachaTypeIndex;
        int cost = 0;

        // 타입에 맞는 비용 설정
        switch (type)
        {
            case GachaType.Normal:
                cost = normalGachaCost;
                break;
            case GachaType.Advanced:
                cost = advancedGachaCost;
                break;
            case GachaType.Rare:
                cost = rareGachaCost;
                break;
        }

        // 재화 확인 및 차감
        PlayerData playerData = EquipmentManager.Instance.currentPlayerData;
        if (playerData.rCoin < cost)
        {
            // Debug.Log("RCoin이 부족합니다.");
            return;
        }
        
        SoundManager.Instance.PlaySFX("SFX_UI_UseCoin");
        
        playerData.rCoin -= cost;
        GameDataManager.Instance.SavePlayerData(playerData);
        UpdateRCoinDisplay();
        
        // 애니메이션 코루틴 시작
        StartCoroutine(StartGachaAnimation(type));
    }

    private IEnumerator StartGachaAnimation(GachaType type)
    {
        isGachaInProgress = true;
        normalDrawButton.interactable = false;
        advancedDrawButton.interactable = false;
        rareDrawButton.interactable = false;

        try
        {
            gachaAnimationPanel.SetActive(true);
            SoundManager.Instance.PlaySFX("SFX_UI_Gacha");
            
            gachaSlider.value = 0;
            if (rewardDescriptionText != null) rewardDescriptionText.text = "";
            if (gachaCloseButton != null) gachaCloseButton.SetActive(false);
            
            EquipmentDataModel finalRewardData = LootManager.Instance.GetRandomEquipmentFromGacha(type);
            if (finalRewardData == null)
            {
                Debug.LogError("가챠에서 장비를 뽑지 못했습니다. LootManager를 확인하세요.");
                yield break;
            }

            // 아이콘 프리로딩 시작
            List<Sprite> droppableSprites = new List<Sprite>();
            List<EquipmentDataModel> allEquipment = LootManager.Instance.AllDroppableEquipment;
            
            if (allEquipment != null)
            {
                foreach (var item in allEquipment)
                {
                    Sprite loadedSprite = Resources.Load<Sprite>(item.iconPath);
                    if (loadedSprite != null) droppableSprites.Add(loadedSprite);
                }
            }
            
            float elapsedTime = 0f;
            float slotChangeTimer = 0f;
            while (elapsedTime < gachaAnimationDuration)
            {
                elapsedTime += Time.deltaTime;
                gachaSlider.value = elapsedTime / gachaAnimationDuration;
                slotChangeTimer -= Time.deltaTime;
                if (slotChangeTimer <= 0f)
                {
                    slotChangeTimer = Random.Range(0.02f, 0.1f);
                    if (droppableSprites.Count > 0)
                    {
                        rewardImage.sprite = droppableSprites[Random.Range(0, droppableSprites.Count)];
                        EquipmentDataModel randomItem = allEquipment[Random.Range(0, allEquipment.Count)];
                        string rarityColor = GetColorForRarity(randomItem.rarity);
                        rewardNameText.text = $"<color={rarityColor}>{randomItem.equipmentName}</color>";
                    }
                }
                yield return null;
            }

            // 최종 결과 표시
            gachaSlider.value = 1;
            rewardImage.sprite = Resources.Load<Sprite>(finalRewardData.iconPath);
            string finalRarityColor = GetColorForRarity(finalRewardData.rarity);
            rewardNameText.text = $"<color={finalRarityColor}>{finalRewardData.equipmentName}</color>";
            if (rewardDescriptionText != null) rewardDescriptionText.text = finalRewardData.description;
            SoundManager.Instance.PlaySFX("SFX_System_WaveClear");

            PlayerEquipmentInstance newInstance = EquipmentManager.Instance.CreateRandomizedEquipmentInstance(finalRewardData);
            EquipmentManager.Instance.AddEquipmentToPlayer(newInstance, false);
        }
        finally
        {
            if (gachaCloseButton != null) gachaCloseButton.SetActive(true);
            isGachaInProgress = false;
            UpdateRCoinDisplay();
        }
    }
    
    /// <summary>
    /// 뽑기 '결과' 패널만 닫는 메소드입니다.
    /// </summary>
    public void CloseGachaPanel()
    {
        // 뽑기 애니메이션 중에는 닫히지 않도록 방지
        if (gachaAnimationPanel != null && !isGachaInProgress)
        {
            gachaAnimationPanel.SetActive(false);
        }
    }
    
    /// <summary>
    /// 상점 패널 전체를 닫는 메소드입니다.
    /// </summary>
    // 상점 패널을 닫는 기능을 하는 메소드
    public void CloseShopPanel()
    {
        // 뽑기 애니메이션 중에는 닫히지 않도록 방지
        if (isGachaInProgress) return;

        // this.gameObject는 ShopManager.cs 스크립트가 붙어있는 'ShopPanel' 프리팹 전체를 의미합니다.
        this.gameObject.SetActive(false);
        SoundManager.Instance.PlaySFX("SFX_UI_ButtonClick");
    }
    
    private string GetColorForRarity(Rarity rarity)
    {
        switch (rarity)
        {
            case Rarity.Common: return "#808080";
            case Rarity.Uncommon: return "green";
            case Rarity.Rare: return "blue";
            case Rarity.Epic: return "purple";
            case Rarity.Legendary: return "orange";
            default: return "white";
        }
    }
}13:T9bc,using UnityEngine;
using System;
using System.Collections.Generic;
using Random = UnityEngine.Random;

[CreateAssetMenu(fileName = "Skill_StatueOfDestructionGod", menuName = "SpecialSkills/Passive/StatueOfDestructionGod")]
public class Skill_StatueOfDestructionGod : EquipmentPassiveSkill
{
    [Header("파괴신의 조각상 설정")]
    [Range(0f, 1f)]
    public float activationChance = 0.05f; // 5% 확률
    [Range(0f, 1f)]
    public float damagePercentage = 0.10f; // 최대 체력의 10% 데미지

    // 스킬 발동 횟수를 저장할 변수
    // NonSerialized 어트리뷰트는 플레이 모드를 종료해도 런타임에 변경된 값이 저장되지 않도록 합니다.
    [NonSerialized]
    public int activationCount = 0;
    
    public override void ApplyGameEffect()
    {
        // 스킬 효과가 적용될 때(게임 시작, 장착 시) 발동 횟수를 초기화
        activationCount = 0;
        EnemySpawner.OnEnemyKilled += OnEnemyKilled; // 적 처치 이벤트 구독
    }

    public override void RemoveGameEffect()
    {
        EnemySpawner.OnEnemyKilled -= OnEnemyKilled; // 적 처치 이벤트 구독 해제
    }

    private void OnEnemyKilled()
    {
        if (Random.value <= activationChance)
        {
            activationCount++;
            UIEventManager.Instance.ShowSystemMessage(SystemType.StatueOfDestructionGod);
            SoundManager.Instance.PlaySFX("SFX_Skill_Explosion");
        
            if (GameManager.Instance != null && GameManager.Instance.enemySpawner != null)
            {
                // 원본 리스트의 '복사본'을 만듭니다.
                var enemyListCopy = new List<Enemy>(GameManager.Instance.enemySpawner.EnemyList);

                // 이제 원본이 아닌 '복사본' 리스트를 순회하여 안전합니다.
                foreach (Enemy enemy in enemyListCopy)
                {
                    if (enemy != null)
                    {
                        EnemyHP enemyHP = enemy.GetComponent<EnemyHP>();
                        if (enemyHP != null)
                        {
                            enemyHP.TakeDamage(enemyHP.MaxHP * damagePercentage);
                        }
                    }
                }
            }
            else
            {
                Debug.LogWarning("[Skill_StatueOfDestructionGod] Required references (GameManager, EnemySpawner) are null. Cannot apply damage to enemies.");
            }
        }
    }
}
c:["$","main",null,{"className":"mx-auto max-w-6xl px-4 py-16 space-y-12","children":[["$","section",null,{"className":"grid gap-8 md:grid-cols-2 items-stretch","children":[["$","div",null,{"className":"rounded-xl overflow-hidden shadow-sm","children":["$","$Ld",null,{"src":"/SiteLogo.png","alt":"RogueTower 메인","className":"w-full h-full object-cover"}]}],["$","div",null,{"className":"flex flex-col justify-between","children":[["$","div",null,{"children":[["$","h1",null,{"className":"text-4xl font-bold underline decoration-blue-500 underline-offset-8","children":"RogueTower"}],["$","dl",null,{"className":"grid grid-cols-[120px_1fr] gap-x-4 gap-y-6 text-gray-800 mt-8","children":[["$","dt",null,{"className":"font-semibold text-gray-600","children":"ROLE"}],["$","dd",null,{"children":"Programmer, Game Designer, Artist"}],["$","dt",null,{"className":"font-semibold text-gray-600","children":"DURATION"}],["$","dd",null,{"children":"2024.10 ~ 2025.08"}],["$","dt",null,{"className":"font-semibold text-gray-600","children":"TEAM"}],["$","dd",null,{"children":"1인 개발"}],["$","dt",null,{"className":"font-semibold text-gray-600","children":"PLATFORM"}],["$","dd",null,{"children":"PC"}]]}]]}],["$","div",null,{"className":"mt-6 flex gap-4","children":["$","a",null,{"href":"https://github.com/WooGeun-Nam/RogueTower-Code","target":"_blank","rel":"noopener noreferrer","className":"inline-flex items-center gap-2 rounded-full px-5 py-3 text-sm font-semibold bg-gray-200 text-gray-900 hover:bg-gray-300 focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-blue-300","children":"GitHub Source"}]}]]}]]}],["$","section",null,{"className":"pt-8","children":["$","$Le",null,{"codeAssets":{"SoundManager":"$f","ExceptionReporter":"$10","LoadingSceneController":"$11","ShopManager":"$12","StatueOfDestructionGod":"$13"}}]}]]}]
